Полный список заголовков файла "протоколы СВЕЧЕЙ" (CSV) / Лист : ”свечи” ​ протоколы СВЕЧЕЙ
Колонка
Заголовок
Формула
Пример
A
time 

02.12.2025 1:00:00
B
text

Binance · ETH USDT Perp · 1W O 4,470.66 H 4,957.67 L 4,060.00 C 4,778.32 V 224.09B Change +307.66(+6.88%) Amplitude 897.67(20.08%) Active Buy/Sell Volume Buy 24.80M Sell -25.71M Delta -906.58K Ratio -0.02 Active Buy/Sell Trades Buy 29.02M Sell -28.87M Delta 149.71K Ratio 0.00 Open Interest O 2.18M H 2.37M L 2.10M C 2.27M Liquidation Long 92.52M Short -85.86M
C
TF

1W
D
O

4 470,66
E
H

4 957,67
F
L

4 060,00
G
C

4 778,32
H
V

224 090 000 000,00
I
Change_abs

307,66
J
Change_%

6,88
K
Amplitude_abs

897,67
L
Amplitude_%

20,08%
M
ABV_Buy

24 800 000,00
N
ABV_Sell

25 710 000,00
O
ABV_Delta

-906 580,00
P
ABV_Ratio
=ARRAYFORMULA(IF(B2:B="";; IF((ABS(M2:M)+ABS(N2:N))=0;; 
  ( (M2:M - ABS(N2:N)) / (ABS(M2:M)+ABS(N2:N)) ) * 100 )))
-1,80
Q
Trades_Buy

29 020 000,00
R
Trades_Sell

28 870 000,00
S
Trades_Delta

149 710,00
T
Trades_Ratio
=ARRAYFORMULA(IF(B2:B="";; IF((ABS(Q2:Q)+ABS(R2:R))=0;; 
  ((Q2:Q - ABS(R2:R)) / (ABS(Q2:Q)+ABS(R2:R)) ) * 100 )))


0,26
U
OI_O

2 180 000,00
V
OI_H

2 370 000,00
W
OI_L

2 100 000,00
X
OI_C

2 270 000,00
Y
Liq_Long

92 520 000,00
Z
Liq_Short

85 860 000,00
AA
H−L
=ARRAYFORMULA(IF(B2:B="";"";E2:E - F2:F))

897,67
AB
C−O
=ARRAYFORMULA(IF(B2:B="";"";G2:G - D2:D))

307,66
AC
Δ% (C−O/O)
=ARRAYFORMULA(
  IF(B2:B="";;
    IF(D2:D=0;;
      (G2:G - D2:D) / D2:D * 100
    )
  )
)

6,88
AD
OI_units
=ARRAYFORMULA(
IF(B2:B="";""; 
  IF(
    REGEXMATCH(
      SUBSTITUTE(B2:B;CHAR(160);" ");
      "Open Interest [^L]* (USDT|USD|\$)"
    );
    "USDT";
    IF(
      REGEXMATCH(
        SUBSTITUTE(B2:B;CHAR(160);" ");
        "Open Interest [^L]* (coin|COIN|BTC|ETH|SOL|XRP|ADA)"
      );
      "coin";
      "contracts"
    )
  )
))


contracts
AE
ΔOI_%
=ARRAYFORMULA(
  IF(ROW(A2:A)=1;"ΔOI_%";
    IF(LEN(U2:U)=0; ;
      LET(
        O; VALUE(SUBSTITUTE(SUBSTITUTE(U2:U;CHAR(160);"");" ";""));
        C; VALUE(SUBSTITUTE(SUBSTITUTE(X2:X;CHAR(160);"");" ";""));
        IF(O=0; ; ROUND((C - O) / O * 100; 4))
      )
    )
  )
)


4,13
AF
Asset

ETH
AG
POROG_ΔOI_%
=ARRAYFORMULA(
 IF(LEN(C2:C)=0; ;
  LET(
    tf_key; LOWER(REGEXREPLACE(C2:C; "\s+"; ""));
    asset; UPPER(AF2:AF);
    colix; MATCH(asset; UPPER('пороги'!B1:F1); 0);
    coef; INDEX('пороги'!B2:F2; ; colix);
    sens_col; INDEX('пороги'!B3:F9; ; colix);
    sens; VLOOKUP(
            tf_key;
            {LOWER('пороги'!A3:A9)\sens_col};
            2; FALSE
          );
    sens*coef
  )
 )
)


1,5500
AH
r
=ARRAYFORMULA( IF(LEN(AE2:AE)=0; ; ABS(AE2:AE) / AG2:AG ) )
2,6635
AI
ε
=ARRAYFORMULA( IF(LEN(AG2:AG)=0; ; ROUND(0,33 * AG2:AG; 4) ) )

0,5115
AJ
CLV п.п.
=ARRAYFORMULA(
  IF(LEN(E2:E)=0; ;
    LET(
      Cn; VALUE(SUBSTITUTE(SUBSTITUTE(G2:G;CHAR(160);"");" ";""));
      Hn; VALUE(SUBSTITUTE(SUBSTITUTE(E2:E;CHAR(160);"");" ";""));
      Ln; VALUE(SUBSTITUTE(SUBSTITUTE(F2:F;CHAR(160);"");" ";""));
      ROUND( IF(Hn=Ln; 50; (Cn-Ln)/(Hn-Ln)*100) ; 1 )
    )
  )
)

80,00
AK
LiqShare п.п.
=ARRAYFORMULA(
  IF(LEN(H2:H)=0; ;
    LET(
      Vn;      VALUE(SUBSTITUTE(SUBSTITUTE(H2:H;CHAR(160);"");" ";""));
      Llong;   ABS(VALUE(SUBSTITUTE(SUBSTITUTE(Y2:Y;CHAR(160);"");" ";"")));
      Lshort;  ABS(VALUE(SUBSTITUTE(SUBSTITUTE(Z2:Z;CHAR(160);"");" ";"")));
      ROUND( ((Llong+Lshort)/Vn)*100 ; 2 )
    )
  )
)

0,08
AL
Limb
=ARRAYFORMULA(
  IF(LEN(Y2:Y)=0; ;
    LET(
      Llong;   ABS(VALUE(SUBSTITUTE(SUBSTITUTE(Y2:Y;CHAR(160);"");" ";"")));
      Lshort;  ABS(VALUE(SUBSTITUTE(SUBSTITUTE(Z2:Z;CHAR(160);"");" ";"")));
      denom;   Llong + Lshort;
      IF(denom=0; ; (Lshort - Llong)/denom)
    )
  )
)

- 0,04
AM
ABV_Ratio, %
=ARRAYFORMULA(
  IF(LEN(M2:M)=0; ;
    LET(
      Buy;  VALUE(SUBSTITUTE(SUBSTITUTE(M2:M;CHAR(160);"");" ";""));
      Sell; VALUE(SUBSTITUTE(SUBSTITUTE(N2:N;CHAR(160);"");" ";""));
      Delta; Buy + Sell;
      Den;   ABS(Buy) + ABS(Sell);
      IF(Den=0; ; ROUND( Delta / Den * 100 ; 1 ))
    )
  )
)

100,00
AN
Trades_Ratio, %
=ARRAYFORMULA(
  IF(LEN(Q2:Q)=0; ;
    LET(
      Buy;  VALUE(SUBSTITUTE(SUBSTITUTE(Q2:Q;CHAR(160);"");" ";""));
      Sell; VALUE(SUBSTITUTE(SUBSTITUTE(R2:R;CHAR(160);"");" ";""));
      Delta; Buy + Sell;
      Den;   ABS(Buy) + ABS(Sell);
      IF(Den=0; ; ROUND( Delta / Den * 100 ; 1 ))
    )
  )
)


100,00
AO
Avg_trade _Buy
=ARRAYFORMULA(
  IF(ROW(A2:A)=1;"Avg_trade_Buy";
    IF(LEN(TRIM(B2:B))=0;""; 
      IFERROR(ROUND( ABS(N(M2:M)) / N(Q2:Q) ; 2) ; "")
    )
  )
)

0,85
AP
Avg_trade_Sell
=ARRAYFORMULA(
  IF(ROW(A2:A)=1;"Avg_trade_Sell";
    IF(LEN(TRIM(B2:B))=0;""; 
      IFERROR(ROUND( ABS(N(N2:N)) / ABS(N(R2:R)) ; 2) ; "")
    )
  )
)


0,89
AQ
Tilt%
=ARRAYFORMULA(
  IF(LEN(M2:M)=0; ;
    IFERROR(
      ROUND(
        (
          ( ABS(VALUE(SUBSTITUTE(SUBSTITUTE(N2:N;CHAR(160);"");" ";""))) /
            ABS(VALUE(SUBSTITUTE(SUBSTITUTE(R2:R;CHAR(160);"");" ";""))) )
          /
          ( ABS(VALUE(SUBSTITUTE(SUBSTITUTE(M2:M;CHAR(160);"");" ";""))) /
            ABS(VALUE(SUBSTITUTE(SUBSTITUTE(Q2:Q;CHAR(160);"");" ";""))) )
          - 1
        )*100
      ; 1)
    ; )
  )
)


4,20
AR
OE
=ARRAYFORMULA(
  IF(LEN(AE2:AE)=0; ;
    LET(
      dOI; AE2:AE;
      dP;  VALUE(SUBSTITUTE(SUBSTITUTE(SUBSTITUTE(AC2:AC;CHAR(160);"");" ";"");"%";""));
      den; ABS(dP);
      IF(den=0; "N/A"; ROUND(dOI/den; 2))
    )
  )
)

0,60
AS
DPX
=ARRAYFORMULA(
  IF(A2:A=""; "";
    LET(
      dp;  VALUE(SUBSTITUTE(SUBSTITUTE(SUBSTITUTE(AC2:AC;CHAR(160);"");" ";"");"%";""));
      cv;  VALUE(SUBSTITUTE(SUBSTITUTE(O2:O;CHAR(160);"");" ";""));
      IFERROR( --(SIGN(dp)<>SIGN(cv)); "" ) )))

1,00
AT
Range%
=ARRAYFORMULA(
  IF(LEN(E2:E)=0; ;
    ROUND(
      ( VALUE(SUBSTITUTE(SUBSTITUTE(E2:E;CHAR(160);"");" ";"")) - VALUE(SUBSTITUTE(SUBSTITUTE(F2:F;CHAR(160);"");" ";"")) )
      / VALUE(SUBSTITUTE(SUBSTITUTE(G2:G;CHAR(160);"");" ";"")) * 100
    ; 2)
  )
)

18,79
AU
-


AV
-


AW
Ratio-стабильность
=ARRAYFORMULA(
  IF(LEN(AM2:AM)=0; ;
    IF( SIGN(AM2:AM)=SIGN(AN2:AN); "Да"; "Нет" )
  )
)


Да
AX
Close_pos
=ARRAYFORMULA(
  IF(LEN(A2:A)=0; ;
    LET(
      CLV; AJ2:AJ;
      IF(CLV=""; ;
        IFS(
          CLV<=5; "у лоя";
          CLV<20; "в нижней части диапазона";
          CLV<33,3334; "в нижней трети диапазона";
          CLV<40; "ниже середины диапазона";
          CLV<45; "ближе к середине (ниже) диапазона";
          CLV<=55; "в середине диапазона";
          CLV<=60; "ближе к середине (выше) диапазона";
          CLV<66,6667; "выше середины диапазона";
          CLV<80; "в верхней трети диапазона";
          CLV<95; "в верхней части диапазона";
          TRUE; "у хая"
        )
      )
    )
  )
)

в верхней части диапазона
AY
Body_%
=ARRAYFORMULA(IF(LEN(A2:A)=0; ; IF(E2:E-F2:F>0; ROUND(ABS(G2:G-D2:D)/(E2:E-F2:F)*100; 2); )))

34,27
AZ
Тело_свечи
=ARRAYFORMULA(
  IF(AY2:AY="";
     "";
     IFS(
       AY2:AY<5;   "доджи";
       AY2:AY<15;  "сверхмалое тело";
       AY2:AY<25;  "малое тело";
       AY2:AY<50;  "среднее− тело";
       AY2:AY<60;  "среднее+ тело";
       AY2:AY<80;  "крупное тело";
       AY2:AY<95;  "очень крупное тело";
       AY2:AY<=100;"почти полное (марубозу)";
       TRUE;       "вне диапазона"
     )
  )
)


среднее− тело
BA
Color
=ARRAYFORMULA(
  IF(LEN(A2:A)=0; ;
    LET(
      O_; VALUE(SUBSTITUTE(SUBSTITUTE(D2:D;CHAR(160);"");" ";""));
      C_; VALUE(SUBSTITUTE(SUBSTITUTE(G2:G;CHAR(160);"");" ";""));
      IF(C_<O_;"красная";"зелёная")
    )
  )
)


зелёная
BB
Цена_vs_дельта
=ARRAYFORMULA(
  IF(A2:A=""; "";
    IFERROR( IF(AS2:AS=1; "дивергенция (Dpx=1)"; "совпадает (Dpx=0)"); "" )
  )
)

дивергенция (Dpx=1)
BC
OIpos
=ARRAYFORMULA(
  IF(ROW(A2:A)=1;"OIpos";
    IF(LEN(TRIM(B2:B))=0;""; 
      LET(
        OIH;VALUE(SUBSTITUTE(SUBSTITUTE(V2:V;CHAR(160);"");" ";""));
        OIL;VALUE(SUBSTITUTE(SUBSTITUTE(W2:W;CHAR(160);"");" ";""));
        OIC;VALUE(SUBSTITUTE(SUBSTITUTE(X2:X;CHAR(160);"");" ";""));
        rng;OIH-OIL;
        raw;IF(rng=0;0,5;(OIC-OIL)/rng);
        ROUND( IF(raw<0;0; IF(raw>1;1; raw)); 3 )
      )
    )
  )
)


0,63
BD
OI_path
=ARRAYFORMULA(
  IF(A2:A=""; "";
    LET(
      OIO; VALUE(SUBSTITUTE(SUBSTITUTE(U2:U;CHAR(160);"");" ";""));
      OIH; VALUE(SUBSTITUTE(SUBSTITUTE(V2:V;CHAR(160);"");" ";""));
      OIL; VALUE(SUBSTITUTE(SUBSTITUTE(W2:W;CHAR(160);"");" ";""));
      up; ABS(OIH-OIO);
      dn; ABS(OIL-OIO);
      IFERROR( IF(up>dn;"вверх"; IF(up<dn;"вниз"; "нейтр")); "" )
    )
  )
)


вверх
BE
Имплицитная_цена
=ARRAYFORMULA(
  IF(A2:A=""; "";
    LET(
      Vv; VALUE(SUBSTITUTE(SUBSTITUTE(H2:H;CHAR(160);"");" ";""));
      Bv; ABS(VALUE(SUBSTITUTE(SUBSTITUTE(M2:M;CHAR(160);"");" ";"")));
      Sv; ABS(VALUE(SUBSTITUTE(SUBSTITUTE(N2:N;CHAR(160);"");" ";"")));
      IFERROR( ROUND(Vv/(Bv+Sv); 0); "" )
    )
  )
)


4 437,00
BF
Сила_сигнала
=ARRAYFORMULA(
  IF(A2:A=""; "";
    LET(
      r; VALUE(SUBSTITUTE(SUBSTITUTE(AH2:AH;CHAR(160);"");" ";""));
      IFERROR( IF(r>=2; "сильный"; IF(r>=1; "средний"; "слабый")); "" )
    )
  )
)


сильный
BG
OI_flow
=ARRAYFORMULA(
  IF(A2:A=""; "";
    LET(
      doi; VALUE(SUBSTITUTE(SUBSTITUTE(AE2:AE;CHAR(160);"");" ";""));
      IFERROR( IF(doi>0; "новые позиции"; IF(doi<0; "закрытия"; "нейтр.")); "" )
    )
  )
)


новые позиции
BH
LiqFlag
=ARRAYFORMULA(
  IF(A2:A=""; "";
    LET(
      ls; VALUE(SUBSTITUTE(SUBSTITUTE(SUBSTITUTE(AK2:AK;CHAR(160);"");" ";"");"%";""));
      IFERROR( IF(ls>0,3; "Да"; "Нет"); "" )
    )
  )
)


Нет
BI
-


BJ
-


BK
-


BL
-


BM
Биржа
=ARRAYFORMULA(IF(LEN(B2:B)=0; ; TRIM(REGEXEXTRACT(B2:B; "^\s*([^·]+)"))))


Binance
BN
Инструмент
=ARRAYFORMULA(
  IF(LEN(B2:B)=0; ;
    REGEXREPLACE(
      TRIM(REGEXEXTRACT(B2:B; "·([^·]+)·")); 
      "^\s*([A-Za-z]+)\s+([A-Za-z]+)\s+(Perp)\s*$";
      "$1$2 $3"
    )
  )
)


ETHUSDT Perp
BO
upper_tail_pct
=ARRAYFORMULA(
  IF(ROW(A2:A)=1;"upper_tail_pct";
    IF(LEN(AA2:AA)=0; ;
      IF(AA2:AA=0; 0;
        (E2:E - IF(D2:D>G2:G; D2:D; G2:G)) / AA2:AA * 100
      )
    )
  )
)


19,98
BP
lower_tail_pct
=ARRAYFORMULA(
  IF(ROW(A2:A)=1;"lower_tail_pct";
    IF(LEN(AA2:AA)=0; ;
      IF(AA2:AA=0; 0;
        (IF(D2:D<G2:G; D2:D; G2:G) - F2:F) / AA2:AA * 100)
    )
  )
)


45,75
BQ
price_sign
=ARRAYFORMULA(
  IF(ROW(A2:A)=1;"price_sign";
    IF(LEN(TRIM(B2:B))=0; "";
      SIGN(AB2:AB)
    )
  )
)
1,00
BR
dominant_reject
=ARRAYFORMULA(
  IF(ROW(A2:A)=1;"dominant_reject";
    IF(LEN(TRIM(B2:B))=0;"";                                     
      IF( (N(BP2:BP)>=3*N(AY2:AY))*(N(BO2:BO)<=10)*(N(AJ2:AJ)>=85);"bull_Ideal";
      IF( (N(BO2:BO)>=3*N(AY2:AY))*(N(BP2:BP)<=10)*(N(AJ2:AJ)<=15);"bear_Ideal";
      IF( (N(BP2:BP)>=2*N(AY2:AY))*(N(BO2:BO)<=25)*(N(AJ2:AJ)>=75);"bull_Valid";
      IF( (N(BO2:BO)>=2*N(AY2:AY))*(N(BP2:BP)<=25)*(N(AJ2:AJ)<=25);"bear_Valid";
      IF( (N(BP2:BP)>=1,5*N(AY2:AY))*(N(AJ2:AJ)>=65)*(N(BO2:BO)<=0,5*N(BP2:BP));"bull_Loose";
      IF( (N(BO2:BO)>=1,5*N(AY2:AY))*(N(AJ2:AJ)<=35)*(N(BP2:BP)<=0,5*N(BO2:BO));"bear_Loose";
          ""
      ))))))
    )
  )
)

BS
cvd_pct
=ARRAYFORMULA(
    IF(LEN(TRIM(B2:B))=0;"";                        
      IF( (N(M2:M)+N(N2:N))=0; 0;                  
        N(O2:O) / ( N(M2:M) + N(N2:N) ) * 100
      )
    )
  )

-1,79
BT
cvd_small
=ARRAYFORMULA(
    IF(LEN(TRIM(B2:B))=0; "";
      ABS(N(BS2:BS)) < 1
    )
  )


FALSE
BU
cvd_sign
=ARRAYFORMULA(
  IF(ROW(A2:A)=1;"cvd_sign";
    IF(LEN(TRIM(B2:B))=0; "";
      SIGN(N(BS2:BS))
    )
  )
)


-1
BV
ratio_stable
=ARRAYFORMULA(
  IF(ROW(A2:A)=1;"ratio_stable";
    IF(LEN(TRIM(B2:B))=0;""; SIGN(N(BS2:BS)) = SIGN(N(S2:S)))
  )
)


FALSE
BW
oi_in_sens
=ARRAYFORMULA(
  IF(LEN(TRIM(B2:B))=0; ;
    ABS(N(AE2:AE)) <= N(AG2:AG)
  )
)


FALSE
BX
T_набор%
=ARRAYFORMULA(
  IF(LEN(TRIM(B2:B))=0; ;
    LET(
      tf_key; LOWER(REGEXREPLACE(C2:C; "\s+"; ""));
      sens;  XLOOKUP(tf_key; LOWER('пороги'!A3:A9); 'пороги'!H3:H9);
      kset;  XLOOKUP(tf_key; LOWER('пороги'!A3:A9); 'пороги'!I3:I9);
      sens * kset
    )
  )
)


2,05
BY
oi_set
=ARRAYFORMULA(
  IF(LEN(TRIM(B2:B))=0; ;
    N(AE2:AE) > N(BX2:BX)
  )
)


TRUE
BZ
T_встречный%
=ARRAYFORMULA(
  IF(LEN(TRIM(B2:B))=0;""; 
    LET(
      tf_key; LOWER(REGEXREPLACE(C2:C;"\s+";""));
      sens;  XLOOKUP(tf_key; LOWER('пороги'!A3:A9); 'пороги'!H3:H9);
      kctr;  XLOOKUP(tf_key; LOWER('пороги'!A3:A9); 'пороги'!J3:J9);
      sens * kctr
    )
  )
 )


2,40
CA
oi_counter
=ARRAYFORMULA(
  IF(LEN(TRIM(B2:B))=0;""; 
    ((N(AS2:AS)=1) * (N(AE2:AE) > N(BZ2:BZ))) > 0
  )
)


TRUE
CB
T_разгрузка%
=ARRAYFORMULA(
  IF(LEN(TRIM(B2:B))=0;""; 
    LET(
      tf_key; LOWER(REGEXREPLACE(C2:C;"\s+";""));
      sens;  XLOOKUP(tf_key; LOWER('пороги'!A3:A9); 'пороги'!H3:H9);
      kunl;  XLOOKUP(tf_key; LOWER('пороги'!A3:A9); 'пороги'!K3:K9);
      -(sens*kunl)
    )
  )
)


-2,25
CC
oi_unload
=ARRAYFORMULA(
  IF(ROW(CC2:CC)=1;"oi_unload";
    IF(LEN(TRIM(B2:B))=0;""; 
      N(AE2:AE) <= N(CB2:CB)
    )
  )
)


FALSE
CD
Limb%
=ARRAYFORMULA(
  IF(LEN(Y2:Y)=0; ;
    LET(
      Llong;  ABS(VALUE(SUBSTITUTE(SUBSTITUTE(Y2:Y;CHAR(160);"");" ";"")));
      Lshort; ABS(VALUE(SUBSTITUTE(SUBSTITUTE(Z2:Z;CHAR(160);"");" ";"")));
      denom;  Llong + Lshort;
      IF(denom=0; ; ROUND(((Lshort - Llong)/denom)*100; 2))
    )
  )
)


-3,73
CE
liq_squeeze
=ARRAYFORMULA(
  IF(ROW(A2:A)=1;"liq_squeeze";
    IF(LEN(TRIM(B2:B))=0;""; N(AK2:AK)>0,3 )
  )
)


FALSE
CF
oe_modul
=ARRAYFORMULA(
  IF(ROW(A2:A)=1;"OE";
    IF(LEN(TRIM(B2:B))=0;""; 
      IFERROR( ROUND( ABS(N(AE2:AE)) / ABS(N(AC2:AC)); 3 ); "N/A")
    )
  )
)


0,60
CG
oi_path
=ARRAYFORMULA(
  IF(ROW(A2:A)=1;"OI_path";
    IF(LEN(TRIM(B2:B))=0;""; 
      IF(N(AE2:AE)>0;"up";IF(N(AE2:AE)<0;"down";"neutral"))
    )
  )
)


up
CH
dpx_2
=ARRAYFORMULA(
  IF(ROW(A2:A)=1;"DPX";
    IF(LEN(TRIM(B2:B))=0;""; 
      SIGN(N(BQ2:BQ)) * SIGN(N(BS2:BS))
    )
  )
)


-1
CI
price_vs_delta
=ARRAYFORMULA(
  IF(ROW(A2:A)=1;"price_vs_delta";
    IF(LEN(TRIM(B2:B))=0;""; 
      IF(N(CH2:CH)=1;"match"; IF(N(CH2:CH)=-1;"div"; "neutral"))
    )
  )
)


div
CJ
tilt_pct
=ARRAYFORMULA(
  IF(LEN(M2:M)=0; ;
    IFERROR(
      ROUND(
        (
          ( ABS(VALUE(SUBSTITUTE(SUBSTITUTE(M2:M;CHAR(160);"");" ";""))) /
            ABS(VALUE(SUBSTITUTE(SUBSTITUTE(Q2:Q;CHAR(160);"");" ";""))) )
          /
          ( ABS(VALUE(SUBSTITUTE(SUBSTITUTE(N2:N;CHAR(160);"");" ";""))) /
            ABS(VALUE(SUBSTITUTE(SUBSTITUTE(R2:R;CHAR(160);"");" ";""))) )
          - 1
        )*100
      ; 1)
    ; )
  )
)


-4,00
CK
geo_score
=ARRAYFORMULA(IF(LEN(A2:A)=0;;((AJ2:AJ>=80)+(AJ2:AJ<=20))*2+(IF(BO2:BO>=30;1;0))+(IF(AY2:AY>=30;1;0))))
3,00
CL
flow_score
=ARRAYFORMULA(
  IF(LEN(TRIM(B2:B))=0;""; 
    LET(
      doi_abs;    ABS(N(AE2:AE));
      tf_key;     LOWER(REGEXREPLACE(C2:C;"\s+";""));
      sens_adapt; IF(tf_key="1d"; N(d_4h_porogi!$O$2);
                IF(tf_key="4h"; N(d_4h_porogi!$P$2);
                IF(tf_key="1w"; N(d_4h_porogi!$Q$2); 0)));
      main_score; IF(doi_abs>=sens_adapt; 2;
                IF(doi_abs>=0,5*sens_adapt; 1; 0));
      dpx_bonus;   IF(N(CH2:CH)=-1; 1; 0);
      ratio_bonus; IF(BV2:BV; 1; 0);
      main_score + dpx_bonus + ratio_bonus
    )
  )
)


3,00
CM
liq_penalty
=ARRAYFORMULA(
  IF(LEN(TRIM(B2:B))=0;""; 
    LET(
      liq_pp;   AK2:AK;
      squeeze;  'пороги'!$B$28;
      warning;  'пороги'!$B$29;
      IF(liq_pp>=squeeze; -2;
       IF(liq_pp>=warning; -1; 0)
      )
    )
  )
)


0,00
CN
rq_calculated
=ARRAYFORMULA(
  IF(LEN(TRIM(B2:B))=0;""; 
    LET(
      sum_raw; N(CK2:CK)+N(CL2:CL)+N(CM2:CM);
      IF(sum_raw<0;0;sum_raw)
    )
  )
)


6,00
CR
Композит


CS
X-RAY

ts: 18.08.2025 02:00
exchange: Binance
symbol: ETHUSDT Perp
tf: 1W
open: 4 470,66
high: 4 957,67
low: 4 060,00
close: 4 778,32
volume: 224 090 000 000
buy_volume: 24 800 000
sell_volume: 25 710 000
buy_trades: 29 020 000
sell_trades: 28 870 000
oi_open: 2 180 000
oi_high: 2 370 000
oi_low: 2 100 000
oi_close: 2 270 000
liq_long: 92 520 000
liq_short: 85 860 000
range: 897,67
body_pct: 34,27%
clv_pct: 80,00%
upper_tail_pct: 19,98%
lower_tail_pct: 45,75%
price_sign: 1
dominant_reject: −
cvd_pct: -1,79%
cvd_sign: -1
cvd_small: false
dpx: -1,00
price_vs_delta: div
dtrades_pct: 0,26%
ratio_stable: false
tilt_pct: 4,20%
doi_pct: 4,13%
oi_in_sens: false
oi_set: true
oi_counter: true
oi_unload: false
oipos: 0,63%
oi_path: up
oe: 0,60
liqshare_pct: 0,08%
limb_pct: -3,73%
liq_squeeze: false
range_pct: 18,79%
implied_price: 4 437,00
avg_trade_buy: 0,85
avg_trade_sell: 0,89
CT
Уровни



Лист d_4h_porogi
 (в этот лист я вставляю точно те же самые свечи, что и в лист “Свечи”, только когда мне надо по скрипту сделать отчет “Уровни”. пока на практике это сыровато и не очень удобно вносить данные и туда и туда. просто если в одном листе все это хранить то можно запутаться, потому что по некоторым свечам я считаю только X-RAY и мне например не надо ее в уровнях учитывать. подумай как это все удобно организовать и в плане хранения и в приложении)

Колонка
Заголовок
Формула
Пример
A
time 

02.12.2025 1:00:00
B
text

Binance · ETH USDT Perp · 1W O 4,470.66 H 4,957.67 L 4,060.00 C 4,778.32 V 224.09B Change +307.66(+6.88%) Amplitude 897.67(20.08%) Active Buy/Sell Volume Buy 24.80M Sell -25.71M Delta -906.58K Ratio -0.02 Active Buy/Sell Trades Buy 29.02M Sell -28.87M Delta 149.71K Ratio 0.00 Open Interest O 2.18M H 2.37M L 2.10M C 2.27M Liquidation Long 92.52M Short -85.86M
C
TF
=ARRAYFORMULA(
  IF(B2:B=""; "";
    IFERROR(
      REGEXEXTRACT(SUBSTITUTE(B2:B;CHAR(160);" ");
        "Perp\s·\s([0-9]+[mMhHdDwW])\sO"
      );
      REGEXEXTRACT(SUBSTITUTE(B2:B;CHAR(160);" ");
        "·\s*([0-9]+[mMhHdDwW])\s"
      )
    )
  )
)


1W
D
O
=ARRAYFORMULA(
  IF(B2:B=""; "";
    VALUE(
      SUBSTITUTE(
        SUBSTITUTE(
          SUBSTITUTE(
            SUBSTITUTE(
              REGEXEXTRACT(SUBSTITUTE(B2:B;CHAR(160);" ");" O ([0-9\.,]+)");
              CHAR(160); ""
            );
            "−"; "-"
          );
          ","; ""
        );
        "."; ","
      )
    )
  )
)


4 470,66
E
H
=ARRAYFORMULA(
  IF(B2:B=""; "";
    VALUE(
      SUBSTITUTE(
        SUBSTITUTE(
          SUBSTITUTE(
            SUBSTITUTE(
              REGEXEXTRACT(SUBSTITUTE(B2:B;CHAR(160);" ");" H ([0-9\.,]+)");
              CHAR(160); ""
            );
            "−"; "-"
          );
          ","; ""
        );
        "."; ","
      )
    )
  )
)


4 957,67
F
L
=ARRAYFORMULA(
  IF(B2:B=""; "";
    VALUE(
      SUBSTITUTE(
        SUBSTITUTE(
          SUBSTITUTE(
            SUBSTITUTE(
              REGEXEXTRACT(SUBSTITUTE(B2:B;CHAR(160);" ");" L ([0-9\.,]+)");
              CHAR(160); ""
            );
            "−"; "-"
          );
          ","; ""
        );
        "."; ","
      )
    )
  )
)


4 060,00
G
C
=ARRAYFORMULA(
  IF(B2:B=""; "";
    VALUE(
      SUBSTITUTE(
        SUBSTITUTE(
          SUBSTITUTE(
            SUBSTITUTE(
              REGEXEXTRACT(SUBSTITUTE(B2:B;CHAR(160);" ");" C ([0-9\.,]+)");
              CHAR(160); ""
            );
            "−"; "-"
          );
          ","; ""
        );
        "."; ","
      )
    )
  )
)


4 778,32
H
Range%
=ARRAYFORMULA(
  IF(LEN(E2:E)=0; ;
    ROUND(
      ( VALUE(SUBSTITUTE(SUBSTITUTE(E2:E;CHAR(160);"");" ";"")) - VALUE(SUBSTITUTE(SUBSTITUTE(F2:F;CHAR(160);"");" ";"")) )
      / VALUE(SUBSTITUTE(SUBSTITUTE(G2:G;CHAR(160);"");" ";"")) * 100
    ; 2)
  )
)


18,79
I
rv_tf_1d
=IFERROR(
  MEDIAN(
    FILTER(
      $H$2:$H;
      $C$2:$C="1D";
      ROW($H$2:$H)>=LARGE(
        FILTER(ROW($H$2:$H);$C$2:$C="1D");
        MIN(20;COUNTIF($C$2:$C;"1D"))
      )
    )
  );
  ""
)


6,76
J
rv_tf_4h
=MEDIAN(
  FILTER(
    $H$2:$H;
    $C$2:$C="4H";
    ROW($H$2:$H)>=LARGE(
      FILTER(ROW($H$2:$H);$C$2:$C="4H");
      MIN(20;COUNTIF($C$2:$C;"4H"))
    )
  )
)


1,51
K
rv_tf_1w
=IFERROR(
  MEDIAN(
    FILTER(
      $H$2:$H;
      $C$2:$C="1W";
      ROW($H$2:$H)>=LARGE(
        FILTER(ROW($H$2:$H);$C$2:$C="1W");
        MIN(20;COUNTIF($C$2:$C;"1W"))
      )
    )
  );
  ""
)


15,27
L
vol_k_1d
=MIN(1,4;MAX(0,6;'пороги'!$B$13 * I2/100 ))


0,60
M
vol_k_4h
=MIN(1,4;MAX(0,6;'пороги'!$B$14*J2/100))

0,60
N
vol_k_1w
=MIN(1,4;MAX(0,6;'пороги'!$B$12*K2/100))

0,60
O
sens_adapt_1d
=L2*'пороги'!$B$18
0,54
P
sens_adapt_4h
=M2*'пороги'!$B$19
0,27
Q
sens_adapt_1w
=N2*'пороги'!$B$17
0,72
R
width_pct_1d
=MIN('пороги'!C23;MAX('пороги'!D23;'пороги'!B23*I2))

0,55
S
width_pct_4h
=MIN('пороги'!C24;MAX('пороги'!D24;'пороги'!B24*J2))


0,3
T
width_pct_1w
=MIN('пороги'!C22;MAX('пороги'!D22;'пороги'!B22*K2))

0,7
U
width_abs_1d
=R2/100 * X2

16,58
V
width_abs_4h
=S2/100 * Y2


9,10
W
width_abs_1w
=T2/100 * Z2

19,61
X
last_close_1d
=INDEX($G$2:$G$500;
  MAX(
    IF($C$2:$C$500="1D";
      ROW($C$2:$C$500)-ROW($C$2)+1;
      0
    )
  )
)


3 013,80
Y
last_close_4h
=INDEX($G$2:$G$500;
  MAX(
    IF($C$2:$C$500="4H";
      ROW($C$2:$C$500)-ROW($C$2)+1;
      0
    )
  )
)


3 032,44
Z
last_close_1w
=INDEX($G$2:$G$500;
  MAX(
    IF($C$2:$C$500="1W";
      ROW($C$2:$C$500)-ROW($C$2)+1;
      0
    )
  )
)


2 800,74
AA
atr_1d
=IFERROR(
  LET(
    n; $AF$2;
    tr; FILTER($AE$2:$AE; $C$2:$C="1D"; LEN($AE$2:$AE));
    k; ROWS(tr);
    last; IF(k<=n; tr; INDEX(tr; SEQUENCE(n; 1; k-n+1; 1)));
    AVERAGE(last)
  );
)



187,95
AB
atr_4h
=IFERROR(
  LET(
    n; $AF$1;
    tr; FILTER($AE$2:$AE; $C$2:$C="4H"; LEN($AE$2:$AE));
    k; ROWS(tr);
    last; IF(k<=n; tr; INDEX(tr; SEQUENCE(n; 1; k-n+1; 1)));
    AVERAGE(last)
  );
)



74,89
AC
atr_1w
=IFERROR(
  LET(
    n; $AF$1;
    tr; FILTER($AE$2:$AE; $C$2:$C="1W"; LEN($AE$2:$AE));
    k; ROWS(tr);
    last; IF(k<=n; tr; INDEX(tr; SEQUENCE(n; 1; k-n+1; 1)));
    AVERAGE(last)
  );
)



630,38
AD
prev_close_tf
=ARRAYFORMULA(
 BYROW(ROW(A2:A500);LAMBDA(r;
  IF(INDEX(B:B;r)="";"";
   LET(
    tf;INDEX(C:C;r);
    seq;FILTER(ROW(C$2:C$500);ROW(C$2:C$500)<r;C$2:C$500=tf);
    idx;IFERROR(MAX(seq);r);
    INDEX(G:G;idx)
   )
  )
 ))
)




4 778,32
AE
TR
=ARRAYFORMULA(
  IF(LEN(B2:B)=0; ;
    IF(
      (E2:E-F2:F>=ABS(E2:E-AD2:AD))*(E2:E-F2:F>=ABS(F2:F-AD2:AD));
      E2:E-F2:F;
      IF(
        ABS(E2:E-AD2:AD)>=ABS(F2:F-AD2:AD);
        ABS(E2:E-AD2:AD);
        ABS(F2:F-AD2:AD)
      )
    )
  )
)




897,67
AF
atr_period
это константа
14

Лист пороги

Row
A
B
C
D
E
F
G
H
I
J
K
1
POROG_dOI_%
ETH
BTC
SOL
XRP
ADA

SENS
k_set
k_ctr
k_unl
2
coeff
1
1
1,2
1,1
1,1





3
5m
0,15
0,2
0,24
0,22
0,22

0,1500
2,0000
2,3333
2,0000
4
15m
0,2
0,2
0,24
0,22
0,22

0,2000
2,0000
2,5000
2,2500
5
30m
0,22
0,2667
0,32
0,2933
0,2933

0,2200
1,8182
2,5000
2,0455
6
1h
0,3
0,4
0,48
0,44
0,44

0,3000
1,6667
2,0000
1,8333
7
4h
0,45
0,5
0,7
0,6
0,6

0,4500
1,7778
2,2222
2,0000
8
1d
0,9
1
1,2
1,1
1,1

0,9000
1,3333
1,5556
1,4444
9
1w
1,55
1,55
1,55
1,55
1,55

1,5500
1,3226
1,5484
1,4516
10











11
volatility_reference










12
1W
2,5









13
1D
2









14
4H
0,7









15











16
sensitivity_base










17
1W
1,2









18
1D
0,9









19
4H
0,45









20











21
width_coefficients

max
min







22
1W
0,3
0,7
0,3







23
1D
0,25
0,55
0,2







24
4H
0,33
0,3
0,1







25











26











27
liqshare










28
squeeze
0,3









29
warning
0,2










Скрипты (Apps Script)

Coinglass_Sheets.gs (это я снимаю свечи с Coin glass legend с помощью Tamper Monkey) 
/** Конфиг по умолчанию **/
const DEFAULT_SHEET_NAME = 'свечи';    // лист по умолчанию
const HEADER = ['time','text'];       // шапка (просто для длины/контроля)

function norm_(s){
 return String(s||'')
   .replace(/\u00a0/g,' ')
   .replace(/[\u2009\u200a\u202f]/g,' ')
   .trim();
}

/** Берём лист по имени, не создаём и не трогаем шапку */
function getSheet_(name){
 const ss = SpreadsheetApp.getActiveSpreadsheet();
 const sh = ss.getSheetByName(name);
 if (!sh) {
   throw new Error('Sheet not found: ' + name);
 }
 return sh;
}

/**
* Находим ПЕРВУЮ свободную строку, теперь ориентируемся на колонку B (text).
* Смотрим только на значения display (формулы ="" считаются пустыми).
*/
function nextFreeRow_(sh) {
 const last = sh.getMaxRows(); // максимум строк на листе
 if (last < 2) return 2;       // если только шапка или вообще пусто

 // Берём всю колонку B со 2-й строки
 const colB = sh.getRange(2, 2, last - 1, 1).getDisplayValues();

 // Идём снизу вверх и ищем последнюю непустую
 for (let i = colB.length - 1; i >= 0; i--) {
   if (colB[i][0] !== '') {
     return i + 2 + 1; // +2 потому что начали с 2-й, +1 — следующая строка после последней непустой
   }
 }
 return 2; // если вообще пусто — пишем во 2-ю
}

/** Приём из Tampermonkey (POST) — добавляем строки под шапкой. */
function doPost(e){
 try {
   const payload = JSON.parse(e.postData && e.postData.contents || '{}');
   const rows = Array.isArray(payload.rows) ? payload.rows : [];
   if (!rows.length) return out_({ok:false, error:'no rows'});

   // имя листа: либо из запроса, либо по умолчанию
   const sheetName = payload.sheet || DEFAULT_SHEET_NAME;
   const sh = getSheet_(sheetName);

   const lock = LockService.getDocumentLock();
   lock.tryLock(5000);
   try {
     const data = rows.map(r => [ norm_(r.time), norm_(r.text) ]);
     const startRow = nextFreeRow_(sh);
     sh.getRange(startRow, 1, data.length, HEADER.length).setValues(data);
   } finally {
     lock.releaseLock();
   }
   return out_({ok:true, added: rows.length, sheet: sheetName});
 } catch(err){
   return out_({ok:false, error:String(err)});
 }
}

/** Пинг (GET) — для проверки, что веб-приложение живое */
function doGet() {
 return out_({ok:true, ping:true});
}

function out_(o){
 return ContentService.createTextOutput(JSON.stringify(o))
   .setMimeType(ContentService.MimeType.JSON);
}

 google-doc.gs (отправка в гугл мне пока не нужна данных)
/************* НАСТРОЙКИ: Google Docs *************/
const DOC_ID = '1w1WO-CgBeWRn-jw2BSQAn4jdyeMST8YezsAatqwKoOA';

// Вкладки Docs (по URL c tab=...)
const TABS = {
 XRAY:          { title: 'X-RAY',          tabId: 't.jwzukx760ad6', mode: 'prepend' }, // новые сверху
 BOKOVIK:       { title: 'БОКОВИК',        tabId: 't.vorsrtirkzmi', mode: 'replace' }, // перезапись
 KNOWLEDGE:     { title: 'KNOWLEDGE',      tabId: 't.aw4ws3g3mwf',  mode: 'replace' },
 STRATEGIC:     { title: 'СТРАТЕГИЧЕСКИЙ', tabId: 't.ha86xu30axxp', mode: 'replace' },
};

const MAROON = '#800000';                  // старый бордовый (оставим на будущее)
const XRAY_PROTOCOL_COLOR = '#2a9900';     // новый зелёный для ПРОТОКОЛ/TF
const XRAY_CLASSIFY_HILITE = '#d2ffa0';    // фон для "Классификация (строго A.2.1): ..."

// Заголовки столбцов (строка 1). Регистр/пробелы не важны.
const HEADER_ALIASES = {
 XRAY:      ['x-ray', 'xray', 'x ray', 'x – ray', 'x-рей', 'x-рэй'],
 BOKOVIK:   ['боковик'],
 KNOWLEDGE: ['knowledge', 'знания'],
 STRATEGIC: ['стратег', 'стратегический', 'стратег.']
};

/************* НАСТРОЙКИ: Telegram *************/
const TELEGRAM_BOT_TOKEN = '8424333200:AAEJxZWzteY2p8SOGXiny631prXYE5Fqxb4';
const TELEGRAM_CHAT_ID   = '-4998564665';      // <-- ГРУППА
const TG_SAFE_LEN = 3800;

/************* МЕНЮ *************/
function onOpen() {
 SpreadsheetApp.getUi()
   .createMenu('Отчёты')
   .addItem('Отправить выделение в Док', 'sendSelectionToDocTabs')
   .addItem('Отправить выделение в Telegram', 'sendSelectionToTelegram')
   .addItem('Сделать композитную сводку', 'makeKompozitForSelection')
   .addItem('Сделать X-RAY', 'makeZeroCalcForSelection')
   .addItem('Сделать Уровни', 'makeLevelsForSelection')

   .addToUi();
}

/************* В ДОК *************/
function sendSelectionToDocTabs() {
 const payloads = buildSelectionPayloads_(); // [{key,cfg,blockText}]
 if (!payloads) return;

 const doc = DocumentApp.openById(DOC_ID);

 payloads.forEach(p => {
   const body = getDocTabBody_(doc, p.cfg);
   if (!body) return;
   const lines = p.blockText.split('\n');
   if (p.cfg.mode === 'replace') {
     writeReplaceWithUuidMarker_(body, lines);
   } else {
     insertPrepend_(body, lines, /*formatXray=*/(p.key === 'XRAY'));
   }
 });

 doc.saveAndClose();
 SpreadsheetApp.getActive().toast(`Готово → ${payloads.map(p=>p.cfg.title).join(', ')}`, 'Отчёты', 4);
}

/************* В TELEGRAM *************/
function sendSelectionToTelegram() {
 const payloads = buildSelectionPayloads_();
 if (!payloads) return;

 payloads.forEach(p => {
   tgSendTextBig_(p.blockText, tabHeaderForKey_(p.key));
 });

 SpreadsheetApp.getActive().toast(`Отправлено в Telegram → ${payloads.map(p=>tabHeaderForKey_(p.key)).join(', ')}`, 'Отчёты', 4);
}


/************* СБОР МНОЖЕСТВЕННОГО ВЫДЕЛЕНИЯ + САНИТАЙЗЕР *************/
// Собираем ВСЕ выделенные ячейки (RangeList), группируем по целевым вкладкам
function buildSelectionPayloads_() {
 const ui  = SpreadsheetApp.getUi();
 const sh  = SpreadsheetApp.getActiveSheet();
 const rl  = sh.getActiveRangeList();
 const r1  = sh.getActiveRange();

 if (!rl && !r1) { ui.alert('Выделите одну или несколько ячеек.'); return null; }

 const colMap = detectColumnsByHeaders_(sh);
 let ranges = rl ? rl.getRanges() : [r1];

 const cells = [];
 ranges.forEach(r => {
   const vals = r.getDisplayValues();
   for (let i = 0; i < r.getNumRows(); i++) {
     for (let j = 0; j < r.getNumColumns(); j++) {
       const text = String(vals[i][j] || '').trim();
       if (!text) continue;
       cells.push({ row: r.getRow() + i, col: r.getColumn() + j, text });
     }
   }
 });

 if (cells.length === 0) { ui.alert('В выделении нет текста.'); return null; }

 cells.sort((a,b)=> a.row - b.row || a.col - b.col);

 const buckets = { XRAY:[], BOKOVIK:[], KNOWLEDGE:[], STRATEGIC:[] };
 cells.forEach(cell => {
   const key = whichBucket_(colMap, cell.col);
   if (key) buckets[key].push(cell.text);
 });

 const payloads = [];
 for (const key of ['XRAY','BOKOVIK','KNOWLEDGE','STRATEGIC']) {
   const arr = buckets[key];
   if (!arr || arr.length === 0) continue;
   const rawBlock  = normalizeNewlines_(arr.join('\n'));
   const blockText = sanitizeMarkdown_(rawBlock);
   payloads.push({ key, cfg: TABS[key], blockText });
 }
 if (payloads.length === 0) {
   ui.alert('Выбранные ячейки не относятся к нужным столбцам.');
   return null;
 }
 return payloads;
}

function tabHeaderForKey_(key) {
 switch (key) {
   case 'XRAY':      return 'X-RAY';
   case 'BOKOVIK':   return 'БОКОВИК';
   case 'KNOWLEDGE': return 'KNOWLEDGE';
   case 'STRATEGIC': return 'СТРАТЕГИЧЕСКИЙ';
   default:          return '';
 }
}

/************* ЗАПИСЬ В ДОК — НАДЁЖНЫЕ РЕЖИМЫ *************/
// prepend (X-RAY): вставляем сверху; перед блоком — пробел-разделитель (не пустая строка)
function insertPrepend_(body, lines, formatXray) {
 if (lines.length === 0) return;
 if (formatXray && body.getNumChildren() > 0) body.insertParagraph(0, ' ');
 for (let i = lines.length - 1; i >= 0; i--) {
   const p = body.insertParagraph(0, lines[i]);
   styleCommonLine_(p, lines[i]);
   if (formatXray) styleXrayLine_(p, lines[i]);
 }
}

// replace с UUID-маркером: новый блок в конец, стираем всё выше маркера, маркер → первая строка
function writeReplaceWithUuidMarker_(body, lines) {
 const firstLine = (lines && lines.length) ? lines[0] : ' ';
 const markerText = '[[__MARKER__' + Utilities.getUuid() + '__]]';

 body.appendParagraph(markerText);
 for (let i = 1; i < lines.length; i++) {
   const p = body.appendParagraph(lines[i]);
   styleCommonLine_(p, lines[i]);
 }

 let markerIndex = -1;
 for (let i = 0; i < body.getNumChildren(); i++) {
   const el = body.getChild(i);
   if (el.getType && el.getType() === DocumentApp.ElementType.PARAGRAPH) {
     if (el.asParagraph().getText() === markerText) { markerIndex = i; break; }
   }
 }
 if (markerIndex === -1) return;

 for (let i = 0; i < markerIndex; i++) {
   body.removeChild(body.getChild(0));
 }

 const firstPara = body.getChild(0).asParagraph();
 firstPara.setText(firstLine);
 styleCommonLine_(firstPara, firstLine);
}

/************* СТИЛИ ДЛЯ X-RAY *************/
function styleXrayLine_(paragraph, line) {
 const t = String(line || '').trim();

 // Главный заголовок блока
 if (t.toUpperCase() === 'РЕНТГЕНОВСКИЙ СНИМОК СВЕЧИ') {
   paragraph.setBold(true);
 }

 // ПРОТОКОЛ СВЕЧИ и TF/Время: — жирный + зелёный текст
 if (isProtocolHeader_(t) || /^TF\/Время:\s*/i.test(t)) {
   paragraph.setBold(true).setForegroundColor(XRAY_PROTOCOL_COLOR);
 }

 // КЛАССИФИКАЦИЯ (строго A.2.1): ... — жирный + фон
 if (/^\s*Классификация\s*\(строго\s*A\.?2\.?1\)\s*:/i.test(t)) {
   paragraph.setBold(true);
   highlightParagraph_(paragraph, XRAY_CLASSIFY_HILITE);
 }
}

function isProtocolHeader_(line) {
 return String(line || '').trim().toUpperCase() === 'ПРОТОКОЛ СВЕЧИ (ДЛЯ КОПИРОВАНИЯ)';
}

/************* ОБЩЕЕ СТИЛИЗОВАНИЕ (ЧИСТЫЕ КАПС-ЗАГОЛОВКИ) *************/
function styleCommonLine_(paragraph, line) {
 const t = String(line || '').trim();
 if (!t) return;
 if (looksLikeCapsHeader_(t)) {
   paragraph.setBold(true);
 } else {
   try { paragraph.setBold(false); } catch (e) {}
 }
}

function looksLikeCapsHeader_(s) {
 if (/^\s*[—-]\s/.test(s)) return false;     // не трогаем пункты списков
 if (/[a-zа-яё]/.test(s)) return false;      // если есть строчные — не заголовок
 const letters = (s.match(/[A-ZА-ЯЁ]/g) || []);
 return letters.length >= 3;                 // ≥3 заглавных буквы
}

/************* ДОСТУП К ВКЛАДКЕ ДОК *************/
function getDocTabBody_(doc, cfg) {
 if (typeof doc.getTabById === 'function') {
   const tab = doc.getTabById(cfg.tabId);
   if (!tab) return null;
   return tab.asDocumentTab().getBody();
 }
 if (typeof doc.getTabs === 'function') {
   const tabs = doc.getTabs();
   for (let i = 0; i < tabs.length; i++) {
     const t = tabs[i];
     if (t.getTitle && t.getTitle() === cfg.title) {
       return t.asDocumentTab().getBody();
     }
   }
 }
 return null;
}

/************* КОЛОНКИ ПО ЗАГОЛОВКАМ *************/
function detectColumnsByHeaders_(sheet) {
 const lastCol = sheet.getLastColumn();
 const headers = sheet.getRange(1, 1, 1, lastCol).getDisplayValues()[0];
 const cleaned = headers.map(h => normHeader_(h));
 const res = { XRAY: null, BOKOVIK: null, KNOWLEDGE: null, STRATEGIC: null };

 function findCol(aliases) {
   for (let i = 0; i < cleaned.length; i++) {
     const h = cleaned[i];
     if (!h) continue;
     for (const a of aliases) {
       if (h === normHeader_(a)) return i + 1;
     }
   }
   return null;
 }

 res.XRAY      = findCol(HEADER_ALIASES.XRAY);
 res.BOKOVIK   = findCol(HEADER_ALIASES.BOKOVIK);
 res.KNOWLEDGE = findCol(HEADER_ALIASES.KNOWLEDGE);
 res.STRATEGIC = findCol(HEADER_ALIASES.STRATEGIC);
 return res;
}

function normHeader_(s) {
 return String(s || '')
   .toLowerCase()
   .replace(/\s+/g, ' ')
   .replace(/ё/g, 'е')
   .trim();
}
function whichBucket_(colMap, colNumber) {
 for (const k of ['XRAY', 'BOKOVIK', 'KNOWLEDGE', 'STRATEGIC']) {
   if (colMap[k] === colNumber) return k;
 }
 return null;
}

/************* САНИТАЙЗЕР MARKDOWN *************/
function sanitizeMarkdown_(text) {
 let s = String(text);
 s = s.replace(/\*\*(.+?)\*\*/gs, '$1');
 s = s.replace(/__(.+?)__/gs, '$1');
 s = s.replace(/^`{1,3}([\s\S]*?)`{1,3}$/gm, '$1');
 return s;
}

/************* УТИЛИТЫ *************/
function normalizeNewlines_(s) {
 return String(s).replace(/\r\n/g, '\n').replace(/\r/g, '\n');
}

// Заливка фона целой строки (параграфа)
function highlightParagraph_(paragraph, color) {
 try {
   const t = paragraph.editAsText();
   const len = t.getText().length;
   if (len > 0) t.setBackgroundColor(0, len - 1, color);
 } catch (e) {}
}

/************* TELEGRAM *************/
function tgSendTextBig_(text) {
 tgSendMessage_(TELEGRAM_CHAT_ID, String(text));
}

function tgSendMessage_(chatId, raw) {
 const url = 'https://api.telegram.org/bot' + TELEGRAM_BOT_TOKEN + '/sendMessage';
 UrlFetchApp.fetch(url, {
   method: 'post',
   contentType: 'application/json',
   payload: JSON.stringify({
     chat_id: chatId,
     text: raw,
     disable_web_page_preview: true
   }),
   muteHttpExceptions: true
 });
}



/************* ЗАГЛУШКА ДЛЯ КНОПКИ "Сделать рентгеновский снимок" *************/
// (оставлена как в твоём меню; наполни логикой при необходимости)
function makeXrayForSelection() {
 SpreadsheetApp.getActive().toast('Функция не реализована (заглушка).', 'Отчёты', 4);
}


x-ray-formulas.gs
/** === НАСТРОЙКИ === **/
const HEADER_ROW = 1;
const TARGET_HEADER_REPORT = 'Отчет';

// точные имена заголовков (регистр не важен)
const HDRS = {
 TIME: 'time',
 O: 'O', H: 'H', L: 'L', C: 'C',
 AMP: 'Amplitude_abs',
 CHABS: 'Change_abs',
 CHPCT: 'Change_%',
 HL: 'H−L',
 CO: 'C−O',
 DPCT: 'Δ% (C−O/O)',

 // CLV уже посчитан в колонке
 CLV: 'CLV п.п.',

 // OI-блок
 OI_UNITS: 'OI_units',
 OI_O: 'OI_O', OI_H: 'OI_H', OI_L: 'OI_L', OI_C: 'OI_C',
 DOI: 'ΔOI_%',
 POROG: 'POROG_ΔOI_% — в долях',
 R: 'r',
 EPS: 'ε',

 // Active Vol / Trades
 ABV_B: 'ABV_Buy',   ABV_S: 'ABV_Sell',   ABV_D: 'ABV_Delta',
 ABV_RATIO: 'ABV_Ratio',         // уже в проц.пунктах
 TR_B:  'Trades_Buy', TR_S:  'Trades_Sell', TR_D:  'Trades_Delta',
 TR_RATIO: 'Trades_Ratio',       // уже в проц.пунктах

 // Ликвидации
 LQ_L: 'Liq_Long',   LQ_S: 'Liq_Short',
 LQ_SHARE: 'LiqShare п.п.',
 LIMB: 'Limb',

 // Avg / Tilt / OE / Dpx
 AVG_B: 'Avg_trade _Buy',
 AVG_S: 'Avg_trade_Sell',
 ASSET: 'Asset',
 TILT:  'Tilt%',
 OE_M:  'OE',
 DPX:   'DPX',

 // Batch-only
 RANGE_PCT: 'Range%',
 PERCENTILE: 'Перцентиль',
 CLV_CLUSTERS: 'CLV-кластеры',
 RATIO_STABLE: 'Ratio-стабильность',

 // Для «Баланс сил / Геометрия»
 COLOR: 'Color',                 // «красная» / «зелёная»
 BODY_LABEL: 'Тело_свечи',       // «крупное тело», «среднее+ тело» и т.п.
 BODY_PCT: 'Body_%',             // число, 0–100
 CLOSE_POS: 'Close_pos',         // текст «в нижней части диапазона» и т.п.
 OIPOS: 'OIpos',                 // 0.00..1.00
 OI_PATH: 'OI_path',             // «вверх»/«вниз»/«нейтр.»

 // Для п.2 «Интенсивность»
 V: 'V',
 IMPL_PRICE: 'Имплицитная_цена',

 STRENGTH: 'Сила_сигнала',   // строка: «сильный/средний/слабый»
 OI_FLOW:  'OI_flow',        // строка: «новые позиции/закрытия/нейтр.»

 LIQFLAG: 'LiqFlag',         // «ликвидационный бар» (Да/Нет)

 TF: 'TF',

 REPORT: TARGET_HEADER_REPORT
};

// допуски на расхождения
const TOL_ABS = 0.01;  // для H−L и Change_abs
const TOL_PP  = 0.01;  // для процентов (п.п.)

/** = Главная команда = **/
function makeXrayForSelection() {
 const sh = SpreadsheetApp.getActiveSheet();
 const sel = sh.getActiveRange();
 if (!sel) return ui_('Выдели строку или диапазон строк.');

 const idx = locate_(sh, Object.values(HDRS));
 const need = [HDRS.AMP, HDRS.CHABS, HDRS.CHPCT, HDRS.HL, HDRS.CO, HDRS.DPCT, HDRS.REPORT];
 if (!need.every(h => idx[h])) {
   return ui_('Проверь заголовки: нужны Amplitude_abs, Change_abs, Change_%, H−L, C−O, Δ% (C−O/O), Отчет.');
 }

 const r1 = Math.max(sel.getRow(), HEADER_ROW + 1);
 const r2 = sel.getLastRow();
 if (r2 < r1) return ui_('Ни одной строки данных под заголовком.');

 const nRows = r2 - r1 + 1;
 const lastCol = sh.getLastColumn();
 const V = sh.getRange(r1, 1, nRows, lastCol).getValues();

 const out = Array.from({ length: nRows }, () => ['']);

 for (let i = 0; i < nRows; i++) {
   // ВАЖНО: если колонки нет — возвращаем undefined, а не первый столбец!
   const val = (name) => (idx[name] ? V[i][idx[name] - 1] : undefined);
   const issues = []; // собираем несоответствия для «Проверка: …»

   // --- 0) Диапазон: H−L vs Amplitude_abs
   let lineRange = '• Диапазон: НЕТ ДАННЫХ';
   if (isNum(val(HDRS.HL)) && isNum(val(HDRS.AMP))) {
     const diff = Math.abs(val(HDRS.HL) - val(HDRS.AMP));
     const ok = diff <= TOL_ABS;
     if (!ok) issues.push('Диапазон (Δ = ' + fmt2(diff) + ')');
     lineRange = '• Диапазон: H−L = ' + fmt2(val(HDRS.AMP)) + ' → ' + (ok ? 'OK' : 'несоответствие (Δ = ' + fmt2(diff) + ')');
   }

   // --- 0) Изменение: C−O и Δ% (C−O/O) vs Change_abs/%
   let lineChange = '• Изменение: НЕТ ДАННЫХ';
   if (isNum(val(HDRS.CO)) || isNum(val(HDRS.DPCT))) {
     const refAbs = val(HDRS.CHABS);
     const refPct = val(HDRS.CHPCT);

     const bad = [];
     if (isNum(val(HDRS.CO)) && isNum(refAbs)) {
       const d = Math.abs(val(HDRS.CO) - refAbs);
       if (d > TOL_ABS) bad.push('Δabs = ' + fmt2(d));
     }
     if (isNum(val(HDRS.DPCT)) && isNum(refPct)) {
       const d = Math.abs(val(HDRS.DPCT) - refPct);
       if (d > TOL_PP) bad.push('Δpp = ' + fmt2(d));
     }

     if (bad.length) issues.push('Изменение (' + bad.join('; ') + ')');

     const showAbs = isNum(val(HDRS.CO)) ? fmt2(val(HDRS.CO)) : 'N/A';
     const showPct = isNum(val(HDRS.DPCT)) ? fmt2(val(HDRS.DPCT)) + '%' : 'N/A';
     const verdict = (isNum(refAbs) || isNum(refPct)) ? (bad.length ? 'несоответствие (' + bad.join('; ') + ')' : 'OK') : 'OK';

     lineChange = '• Изменение: C−O = ' + showAbs + ' (' + showPct + ') → ' + verdict;
   }

   // --- 0) Нормализация: модульность Sell/Short + наличие Δ
   let lineNorm = '• Нормализация: НЕТ ДАННЫХ';
   const haveAny =
     [HDRS.ABV_S].every(h => idx[h]) ||
     [HDRS.TR_S].every(h => idx[h])  ||
     [HDRS.LQ_S].every(h => idx[h]);

   if (haveAny) {
     const problems = [];
     if (idx[HDRS.ABV_S] && isNum(val(HDRS.ABV_S)) && val(HDRS.ABV_S) < 0) problems.push('ABV_Sell<0');
     if (idx[HDRS.TR_S]  && isNum(val(HDRS.TR_S))  && val(HDRS.TR_S)  < 0) problems.push('Trades_Sell<0');
     if (idx[HDRS.LQ_L]  && isNum(val(HDRS.LQ_L))  && val(HDRS.LQ_L)  < 0) problems.push('Liq_Long<0');
     if (idx[HDRS.LQ_S]  && isNum(val(HDRS.LQ_S))  && val(HDRS.LQ_S)  < 0) problems.push('Liq_Short<0');

     if (idx[HDRS.ABV_D] && !isNum(val(HDRS.ABV_D))) problems.push('ABV_Delta: N/A');
     if (idx[HDRS.TR_D]  && !isNum(val(HDRS.TR_D)))  problems.push('Trades_Delta: N/A');

     if (problems.length) issues.push('Нормализация (' + problems.join(', ') + ')');

     lineNorm = '• Нормализация: Sell/Short заданы модулем; знак из Δ → ' +
                (problems.length ? 'проблема: ' + problems.join(', ') : 'OK');
   }

   // --- 0) OI-блок
   let lineOI = '• OI: НЕТ ДАННЫХ';
   const haveOI =
     [HDRS.OI_UNITS, HDRS.OI_O, HDRS.OI_H, HDRS.OI_L, HDRS.OI_C, HDRS.DOI, HDRS.R, HDRS.EPS].every(h => idx[h]);
   if (haveOI &&
       [val(HDRS.OI_O), val(HDRS.OI_H), val(HDRS.OI_L), val(HDRS.OI_C), val(HDRS.DOI), val(HDRS.R), val(HDRS.EPS)]
         .every(isNum)) {
     const units = String(val(HDRS.OI_UNITS) || 'contracts');
     lineOI = '• OI_units: ' + units +
              '; OI O/H/L/C: ' +
              fmtKMB(val(HDRS.OI_O)) + ' / ' +
              fmtKMB(val(HDRS.OI_H)) + ' / ' +
              fmtKMB(val(HDRS.OI_L)) + ' / ' +
              fmtKMB(val(HDRS.OI_C)) +
              ' → ΔOI = ' + fmt2(val(HDRS.DOI)) + '%; r=' + fmt2(val(HDRS.R)) + '; ε=' + fmt2(val(HDRS.EPS));
   }

   // --- 0) CLV
   let lineCLV = '• CLV (пересчёт): N/A';
   if (idx[HDRS.CLV] && isNum(val(HDRS.CLV))) {
     lineCLV = '• CLV (пересчёт): ' + fmt1(val(HDRS.CLV)) + '%';
   }

   // --- 0) Ликвидации
   let lineLiq = '• Ликвидации: НЕТ ДАННЫХ';
   const haveLiq = [HDRS.LQ_L, HDRS.LQ_S].every(h => idx[h]) && (isNum(val(HDRS.LQ_L)) || isNum(val(HDRS.LQ_S)));
   if (haveLiq) {
     const longV = isNum(val(HDRS.LQ_L)) ? fmtKMB(val(HDRS.LQ_L)) : 'N/A';
     const shortV = isNum(val(HDRS.LQ_S)) ? fmtKMB(val(HDRS.LQ_S)) : 'N/A';
     const shareTxt = (idx[HDRS.LQ_SHARE] && isNum(val(HDRS.LQ_SHARE))) ? (fmt2(val(HDRS.LQ_SHARE)) + '%') : 'N/A';
     const limbTxt  = (idx[HDRS.LIMB]     && isNum(val(HDRS.LIMB)))     ?  fmt2(val(HDRS.LIMB))             : 'N/A';
     lineLiq = `• Ликвидации: Long ${longV}, Short ${shortV}; LiqShare = ${shareTxt}, Limb = ${limbTxt}`;
   }

   // --- 0) Active Vol / Active Trades
   let lineAct = '• Active Vol: НЕТ ДАННЫХ';
   const haveABV = [HDRS.ABV_B, HDRS.ABV_S].every(h => idx[h]) && (isNum(val(HDRS.ABV_B)) || isNum(val(HDRS.ABV_S)));
   const haveTR  = [HDRS.TR_B,  HDRS.TR_S ].every(h => idx[h]) && (isNum(val(HDRS.TR_B )) || isNum(val(HDRS.TR_S )));
   if (haveABV || haveTR) {
     // объёмы
     const bV = isNum(val(HDRS.ABV_B)) ? val(HDRS.ABV_B) : null;
     const sV = isNum(val(HDRS.ABV_S)) ? val(HDRS.ABV_S) : null;  // модуль
     const dV = isNum(val(HDRS.ABV_D)) ? val(HDRS.ABV_D) : (bV!=null && sV!=null ? (bV - sV) : null);
     const pV = (idx[HDRS.ABV_RATIO] && isNum(val(HDRS.ABV_RATIO))) ? val(HDRS.ABV_RATIO) : null; // уже %

     const volPart = haveABV
       ? ('Active Vol: ' +
          'Buy '  + (bV==null ? 'N/A' : fmtKMB(bV)) + ', ' +
          'Sell ' + (sV==null ? 'N/A' : ('−' + fmtKMB(sV))) + ', ' +
          'ΔV '   + (dV==null ? 'N/A' : fmtKMB(dV)) + ' ' +
          '(' + (pV==null ? 'N/A' : (fmt1(pV) + '%')) + ')')
       : 'Active Vol: НЕТ ДАННЫХ';

     // сделки
     const bT = isNum(val(HDRS.TR_B)) ? val(HDRS.TR_B) : null;
     const sT = isNum(val(HDRS.TR_S)) ? val(HDRS.TR_S) : null;    // модуль
     const dT = isNum(val(HDRS.TR_D)) ? val(HDRS.TR_D) : (bT!=null && sT!=null ? (bT - sT) : null);
     const pT = (idx[HDRS.TR_RATIO] && isNum(val(HDRS.TR_RATIO))) ? val(HDRS.TR_RATIO) : null;   // уже %

     const tradesPart = haveTR
       ? ('Active Trades: ' +
          'Buy '      + (bT==null ? 'N/A' : fmtKMB(bT)) + ', ' +
          'Sell '     + (sT==null ? 'N/A' : ('−' + fmtKMB(sT))) + ', ' +
          'ΔTrades '  + (dT==null ? 'N/A' : fmtKMB(dT)) + ' ' +
          '(' + (pT==null ? 'N/A' : (fmt1(pT) + '%')) + ')')
       : 'Active Trades: НЕТ ДАННЫХ';

     lineAct = '• ' + volPart + '; ' + tradesPart;
   }

   // --- 0) Avg trade / Tilt / OE / Dpx
   let lineAvg = '• Avg trade: НЕТ ДАННЫХ';
   const haveAvg = [HDRS.AVG_B, HDRS.AVG_S, HDRS.ASSET].every(h => idx[h]);
   const haveTilt = !!idx[HDRS.TILT];
   const haveOE   = !!idx[HDRS.OE_M];
   const haveDPX  = !!idx[HDRS.DPX];

   if (haveAvg || haveTilt || haveOE || haveDPX) {
     const avgB = isNum(val(HDRS.AVG_B)) ? val(HDRS.AVG_B) : null;
     const avgS = isNum(val(HDRS.AVG_S)) ? val(HDRS.AVG_S) : null;
     const asset = String(val(HDRS.ASSET) || '').trim();

     const tilt = isNum(val(HDRS.TILT)) ? val(HDRS.TILT) : null;  // если доля — fmtSignedPct1 переведёт в %
     const oe   = isNum(val(HDRS.OE_M)) ? val(HDRS.OE_M) : null;
     const dpx  = (val(HDRS.DPX) === 0 || val(HDRS.DPX) === 1) ? val(HDRS.DPX) : null;

     const avgPart = (avgB != null && avgS != null && asset)
       ? `Avg trade: Buy ${fmt2(avgB)} ${asset}, Sell ${fmt2(avgS)} ${asset}`
       : 'Avg trade: N/A';

     const tiltPart = 'Tilt% = ' + (tilt == null ? 'N/A' : fmtSignedPct1(tilt));
     const oePart   = 'OE = ' + (oe == null ? 'N/A' : fmt2(oe));
     const dpxPart  = 'Dpx = ' + (dpx == null ? 'N/A' : String(dpx));

     lineAvg = `• ${avgPart}; ${tiltPart}; ${oePart}; ${dpxPart}`;
   }

   // --- 0) Batch-only (Range%, перцентиль, CLV-кластеры, Ratio-стабильность)
   const rangeTxt = (idx[HDRS.RANGE_PCT] && isNum(val(HDRS.RANGE_PCT))) ? (fmt2(val(HDRS.RANGE_PCT)) + '%') : 'N/A';
   const percTxt  = (idx[HDRS.PERCENTILE]  && isNum(val(HDRS.PERCENTILE)))  ? fmt2(val(HDRS.PERCENTILE))  : 'N/A';
   const clvClTxt = (idx[HDRS.CLV_CLUSTERS] && String(val(HDRS.CLV_CLUSTERS) || '').trim() !== '')
                     ? String(val(HDRS.CLV_CLUSTERS)) : 'N/A';

   let ratioStableTxt = 'N/A';
   if (idx[HDRS.RATIO_STABLE]) {
     const s = String(val(HDRS.RATIO_STABLE) || '').trim();
     ratioStableTxt = s ? s : 'N/A';
   } else if (idx[HDRS.ABV_RATIO] && idx[HDRS.TR_RATIO]) {
     const rv = val(HDRS.ABV_RATIO), rt = val(HDRS.TR_RATIO);
     if (isNum(rv) && isNum(rt)) ratioStableTxt = Math.sign(rv) === Math.sign(rt) ? 'Да' : 'Нет';
   }
   const lineBatch = `• Batch-only: Range% = ${rangeTxt} [перцентиль ${percTxt === 'N/A' ? 'Н/A' : percTxt}]; CLV-кластеры: ${clvClTxt}; Ratio-стабильность: ${ratioStableTxt}`;

   // --- 0) Проверка: сводка
   const lineCheck = '• Проверка: ' + (issues.length ? ('проблемы: ' + issues.join('; ')) : 'OK ✅');

   // --- 1) Баланс сил — Геометрия + Цена vs дельта
   const colorTxt = String(val(HDRS.COLOR) || '').trim();
   const bodyLbl  = String(val(HDRS.BODY_LABEL) || '').trim();
   const bodyPctV = val(HDRS.BODY_PCT);
   const bodyPctT = isNum(bodyPctV) ? (fmt2(bodyPctV) + '%') : 'Н/A';
   const closePos = String(val(HDRS.CLOSE_POS) || '').trim();
   const clvTxt   = (idx[HDRS.CLV] && isNum(val(HDRS.CLV))) ? (fmt1(val(HDRS.CLV)) + '%') : 'Н/A';

   let dpxTxt = 'нейтр.';
   if (val(HDRS.DPX) === 0) dpxTxt = 'совпадает (Dpx=0)';
   else if (val(HDRS.DPX) === 1) dpxTxt = 'дивергенция (Dpx=1)';

   const oiPosTxt = (idx[HDRS.OIPOS] && isNum(val(HDRS.OIPOS))) ? fmt2(val(HDRS.OIPOS)) : 'Н/A';
   const oiPathTxt = String(val(HDRS.OI_PATH) || 'Н/A').trim();

   const lineBalance =
     '1. Баланс сил: как распределены удары внутри бара.\n' +
     '• Геометрия: ' +
       (colorTxt ? (colorTxt + ' свеча') : 'цвет N/A') + ', ' +
       (bodyLbl || 'тело N/A') + ' (тело = ' + bodyPctT + ' диапазона), ' +
       'close ' + (closePos || 'N/A') + ' (CLV~' + clvTxt + ').\n' +
     '• Цена vs дельта (Dpx): ' + dpxTxt + '; OIpos = ' + oiPosTxt + '; OI-path: ' + oiPathTxt + '.';

   // --- 2) Интенсивность
   const Vnum = val(HDRS.V);
   const impl = val(HDRS.IMPL_PRICE);
   const assetName2 = String(val(HDRS.ASSET) || '').trim() || '[актив]';
   const vText   = isNum(Vnum) ? (fmtKMB(Vnum) + ' USDT') : 'N/A';
   const implTxt = isNum(impl) ? (fmt0(impl) + ' USDT/' + assetName2) : 'N/A';
   const lineIntensity =
     '2. Интенсивность: насколько «тяжёлым» был оборот.\n' +
     '• V = ' + vText + '; имплицитная цена = ' + implTxt + '.';

   // --- 3) Качество движения (новые деньги vs закрытия)
   const doi = isNum(val(HDRS.DOI)) ? val(HDRS.DOI) : null;     // ΔOI_% (в %)
   const rVal = isNum(val(HDRS.R)) ? val(HDRS.R) : null;        // r
   const oeVal = isNum(val(HDRS.OE_M)) ? val(HDRS.OE_M) : null; // OE
   const strengthTxtRaw = String(val(HDRS.STRENGTH) || '').trim();
   const flowTxtRaw = String(val(HDRS.OI_FLOW) || '').trim();   // новые позиции / закрытия / нейтр.

   function strengthLabel(r){
     if (!isNum(r)) return 'N/A';
     if (r >= 2.0) return 'сильный';
     if (r >= 1.0) return 'средний';
     return 'слабый';
   }
   const strengthTxt = strengthTxtRaw || strengthLabel(rVal);

   const doiTxt = (doi == null) ? 'N/A' : ((doi >= 0 ? '+' : '') + fmt2(doi) + '%');
   const rTxt   = (rVal == null) ? 'N/A' : fmt2(rVal);
   const oeTxt  = (oeVal == null || !isFinite(oeVal)) ? 'N/A' : fmt2(oeVal);
   const flowTxt = flowTxtRaw ? (' — ' + flowTxtRaw) : '';

   const lineQuality =
     '3. Качество движения (новые деньги vs закрытия): рост OI = набор, падение = закрытия; OE показывает «сколько OI на 1% хода».\n' +
     '• ΔOI = ' + doiTxt + flowTxt + '; сила: ' + strengthTxt + ' (r=' + rTxt + '); OE = ' + oeTxt + '.';

   // --- 4) Фактор принуждения: ликвидации и их перекос
   const liqL = isNum(val(HDRS.LQ_L)) ? Math.abs(val(HDRS.LQ_L)) : null;
   const liqS = isNum(val(HDRS.LQ_S)) ? Math.abs(val(HDRS.LQ_S)) : null;
   const liqShare = isNum(val(HDRS.LQ_SHARE)) ? val(HDRS.LQ_SHARE) : null; // уже в %
   const limb = isNum(val(HDRS.LIMB)) ? val(HDRS.LIMB) : null;

   const liqFlagRaw = String(val(HDRS.LIQFLAG) || '').trim().toLowerCase();
   const isLiqBar = liqFlagRaw
     ? (liqFlagRaw !== 'нет' && liqFlagRaw !== 'no' && liqFlagRaw !== 'false')
     : (liqShare != null && liqShare > 0.30);

   const longTxt  = (liqL == null) ? 'N/A' : (fmtKMB(liqL));
   const shortTxt = (liqS == null) ? 'N/A' : ('- ' + fmtKMB(liqS));
   const shareTxt = (liqShare == null) ? 'N/A' : (fmt2(liqShare) + '%');
   const limbTxt  = (limb == null) ? 'N/A' : (limb >= 0 ? fmt2(limb) : ('-' + fmt2(Math.abs(limb))));
   const flagTxt  = isLiqBar ? ' (ликвидационный бар)' : '';

   const lineCoercion =
     '4. Фактор принуждения: вклад ликвидаций (сквиз/чистка) и их перекос.\n' +
     '• Ликвидации Long = ' + longTxt + ', Short = ' + shortTxt + '; ' +
     'LiqShare = ' + shareTxt + flagTxt + '; ' +
     'Limb = ' + limbTxt + '.';

   // --- 5) Флаги-override (заглушка)
   const lineOverrides =
     '5. Флаги-override: условия, которые перевешивают линейную матрицу.\n' +
     '• Поглощение встречной стороны: Надо проанализировать.\n' +
     '• Принятие цены: Надо проанализировать.';

   // --- 6) Классификация (заглушка)
   const lineClassification =
     '6. Классификация (итог): финальный ярлык бара по всем данным.\n' +
     '• Надо проанализировать.';

   // --- 7) Протокол событий (заглушка)
   const lineEvents =
     '7. Протокол событий (коротко): сжатая причинно-следственная цепочка.\n' +
     '• Надо проанализировать.';

   // === 🟩 ПРОТОКОЛ СВЕЧИ (итоговая сводка) ===
   const tfTxt   = String(val(HDRS.TF) || '').trim() || 'N/A';
   const timeTxt = fmtDate(val(HDRS.TIME)) || 'N/A';

   // OHLC
   const oTxt = isNum(val(HDRS.O)) ? fmt2ru(val(HDRS.O)) : 'N/A';
   const hTxt = isNum(val(HDRS.H)) ? fmt2ru(val(HDRS.H)) : 'N/A';
   const lTxt = isNum(val(HDRS.L)) ? fmt2ru(val(HDRS.L)) : 'N/A';
   const cTxt = isNum(val(HDRS.C)) ? fmt2ru(val(HDRS.C)) : 'N/A';


   // Change / Range
   const chAbs = isNum(val(HDRS.CHABS)) ? val(HDRS.CHABS) : null;
   const chPct = isNum(val(HDRS.CHPCT)) ? val(HDRS.CHPCT) : null;
   const rangeAbs = isNum(val(HDRS.AMP)) ? val(HDRS.AMP) : null;
   const rangePct = (idx[HDRS.RANGE_PCT] && isNum(val(HDRS.RANGE_PCT))) ? val(HDRS.RANGE_PCT) : null;

   const chAbsTxt   = (chAbs == null)   ? 'N/A' : ( (chAbs>=0? '' : '-') + fmt2(Math.abs(chAbs)) );
   const chPctTxt   = (chPct == null)   ? 'N/A' : ( (chPct>=0? '' : '-') + fmt2(Math.abs(chPct)) + '%' );
   const rngAbsTxt  = (rangeAbs == null)? 'N/A' : fmt2(rangeAbs);
   const rngPctTxt  = (rangePct == null)? 'N/A' : fmt2(rangePct) + '%';

   // Геометрия
   const geomColor = String(val(HDRS.COLOR) || '').trim() || 'N/A';
   const geomClose = String(val(HDRS.CLOSE_POS) || '').trim() || 'N/A';

   // Active Vol
   const assetName = String(val(HDRS.ASSET) || '').trim() || 'актив';
   const abvB = isNum(val(HDRS.ABV_B)) ? fmtKMB(val(HDRS.ABV_B)) : 'N/A';
   const abvS = isNum(val(HDRS.ABV_S)) ? ('-' + fmtKMB(Math.abs(val(HDRS.ABV_S)))) : 'N/A';
   const abvD = isNum(val(HDRS.ABV_D)) ? ((val(HDRS.ABV_D)>=0? '' : '-') + fmtKMB(Math.abs(val(HDRS.ABV_D)))) : 'N/A';
   const abvR = (idx[HDRS.ABV_RATIO] && isNum(val(HDRS.ABV_RATIO))) ? (fmt1(val(HDRS.ABV_RATIO)) + '%') : 'N/A';

   // Trades
   const trB = isNum(val(HDRS.TR_B)) ? fmtKMB(val(HDRS.TR_B)) : 'N/A';
   const trS = isNum(val(HDRS.TR_S)) ? ('-' + fmtKMB(Math.abs(val(HDRS.TR_S)))) : 'N/A';
   const trD = isNum(val(HDRS.TR_D)) ? ((val(HDRS.TR_D)>=0? '' : '-') + fmtKMB(Math.abs(val(HDRS.TR_D)))) : 'N/A';
   const trR = (idx[HDRS.TR_RATIO] && isNum(val(HDRS.TR_RATIO))) ? (fmt1(val(HDRS.TR_RATIO)) + '%') : 'N/A';

   // Avg trade + Tilt
   const avgBtxt = isNum(val(HDRS.AVG_B)) ? (fmt2(val(HDRS.AVG_B)) + ' ' + assetName) : 'N/A';
   const avgStxt = isNum(val(HDRS.AVG_S)) ? (fmt2(val(HDRS.AVG_S)) + ' ' + assetName) : 'N/A';
   const tiltTxt  = isNum(val(HDRS.TILT)) ? fmtSignedPct1(val(HDRS.TILT)) : 'N/A';

   // V / Импл. цена
   const vTxt     = isNum(val(HDRS.V)) ? fmtKMB(val(HDRS.V)) : 'N/A';
   const implTxt2 = isNum(val(HDRS.IMPL_PRICE)) ? (fmt0(val(HDRS.IMPL_PRICE)) + ' USDT per ' + assetName) : 'N/A';

   // OI-блок
   const oiUnits = String(val(HDRS.OI_UNITS) || 'contracts').trim();
   const oiO = isNum(val(HDRS.OI_O)) ? fmtKMB(val(HDRS.OI_O)) : 'N/A';
   const oiH = isNum(val(HDRS.OI_H)) ? fmtKMB(val(HDRS.OI_H)) : 'N/A';
   const oiL = isNum(val(HDRS.OI_L)) ? fmtKMB(val(HDRS.OI_L)) : 'N/A';
   const oiC = isNum(val(HDRS.OI_C)) ? fmtKMB(val(HDRS.OI_C)) : 'N/A';
   const doiTxt2 = isNum(val(HDRS.DOI)) ? ((val(HDRS.DOI)>=0? '+' : '') + fmt2(val(HDRS.DOI)) + '%') : 'N/A';
   const strengthInline = (String(val(HDRS.STRENGTH) || '').trim()) ||
                          (isNum(val(HDRS.R)) ? (val(HDRS.R)>=2?'сильный':(val(HDRS.R)>=1?'средний':'слабый')) : 'N/A');
   const oiPosTxt2 = (idx[HDRS.OIPOS] && isNum(val(HDRS.OIPOS))) ? fmt2(val(HDRS.OIPOS)) : 'N/A';
   const oiPathTxt2 = String(val(HDRS.OI_PATH) || 'N/A').trim();

   // CLV
   const clvTxt2 = (idx[HDRS.CLV] && isNum(val(HDRS.CLV))) ? (fmt1(val(HDRS.CLV)) + '%') : 'N/A';

   // Ликвидации
   const liqL2 = isNum(val(HDRS.LQ_L)) ? fmtKMB(Math.abs(val(HDRS.LQ_L))) : 'N/A';
   const liqS2 = isNum(val(HDRS.LQ_S)) ? fmtKMB(Math.abs(val(HDRS.LQ_S))) : 'N/A';
   const liqShare2 = (idx[HDRS.LQ_SHARE] && isNum(val(HDRS.LQ_SHARE))) ? (fmt2(val(HDRS.LQ_SHARE)) + '%') : 'N/A';
   const limb2 = (idx[HDRS.LIMB] && isNum(val(HDRS.LIMB))) ? (val(HDRS.LIMB)>=0 ? fmt2(val(HDRS.LIMB)) : ('-' + fmt2(Math.abs(val(HDRS.LIMB))))) : 'N/A';
   const liqFlagInline = (String(val(HDRS.LIQFLAG) || '').trim().toLowerCase());
   const liqSuffix = (liqFlagInline && liqFlagInline !== 'нет' && liqFlagInline !== 'no' && liqFlagInline !== 'false')
                     ? ' (ликвидационный бар)' : '';

   // Batch
   const rangePctTxt2 = (rangePct == null) ? 'N/A' : (fmt2(rangePct) + '%');
   const percTxt2 = (idx[HDRS.PERCENTILE] && isNum(val(HDRS.PERCENTILE))) ? fmt2(val(HDRS.PERCENTILE)) : 'N/A';
   const clvClusters2 = String(val(HDRS.CLV_CLUSTERS) || 'N/A').trim() || 'N/A';
   let ratioStable2 = 'N/A';
   if (idx[HDRS.RATIO_STABLE]) {
     const s = String(val(HDRS.RATIO_STABLE) || '').trim();
     ratioStable2 = s ? s : 'N/A';
   } else if (idx[HDRS.ABV_RATIO] && idx[HDRS.TR_RATIO] && isNum(val(HDRS.ABV_RATIO)) && isNum(val(HDRS.TR_RATIO))) {
     ratioStable2 = (Math.sign(val(HDRS.ABV_RATIO)) === Math.sign(val(HDRS.TR_RATIO))) ? 'Да' : 'Нет';
   }

   // Флаги/Классификация — заглушки
   const flagsTxt = 'Надо проанализировать';
   const classTxt = 'Надо проанализировать';

   const protocol =
     '🟩 ПРОТОКОЛ СВЕЧИ\n' +
     'TF/Время: ' + (tfTxt || 'N/A') + ' / ' + (timeTxt || 'N/A') + '\n' +
     'OHLC: ' + oTxt + ' / ' + hTxt + ' / ' + lTxt + ' / ' + cTxt + '\n' +
     'Change / Range: ' + chAbsTxt + ' (' + chPctTxt + ') / ' + rngAbsTxt + ' (' + rngPctTxt + ')\n' +
     'Геометрия: ' +
       (colorTxt ? (colorTxt + ' свеча') : 'цвет N/A') + ', ' +
       (bodyLbl || 'тело N/A') + ' (тело = ' + bodyPctT + ' диапазона), ' +
       'close ' + (closePos || 'N/A') + ' (CLV~' + clvTxt + ').\n' +
     'Active Vol (' + assetName + '): Buy ' + abvB + ', Sell ' + abvS + ', Delta ' + abvD + ' (' + abvR + ')\n' +
     'Trades: Buy ' + trB + ', Sell ' + trS + ', Delta ' + trD + ' (' + trR + ')\n' +
     'Avg trade: Buy ' + avgBtxt + ', Sell ' + avgStxt + '; Tilt% ' + tiltTxt + '\n' +
     'V / Импл. цена: ' + vTxt + ' / ' + implTxt2 + '\n' +
     'OI_units: ' + oiUnits + '\n' +
     'OI O/H/L/C: ' + oiO + ' / ' + oiH + ' / ' + oiL + ' / ' + oiC + ', ΔOI = ' + doiTxt2 +
     ' (сила: ' + strengthInline + '), OIpos ' + oiPosTxt2 + ', OI-path ' + oiPathTxt2 + '\n' +
     'CLV (пересчёт): ' + clvTxt2 + '\n' +
     'Ликвидации: Long ' + liqL2 + ', Short ' + liqS2 + '; LiqShare ' + liqShare2 + ', Limb ' + limb2 + liqSuffix + '\n' +
     'Batch: Range% ' + rangePctTxt2 + ', перцентиль ' + (percTxt2 || 'N/A') + ', CLV-кластеры ' + clvClusters2 + ', Ratio-стабильность ' + ratioStable2 + '\n' +
     'Флаги: ' + flagsTxt + '\n' +
     'Классификация: ' + classTxt;

   // --- сборка блока
   const block =
     'РЕНТГЕНОВСКИЙ СНИМОК СВЕЧИ\n' +
     '0) Верификация\n' +
     lineRange + '\n' +
     lineChange + '\n' +
     '• Нормализация: ' + lineNorm.slice('• Нормализация: '.length) + '\n' +
     lineOI + '\n' +
     lineCLV + '\n' +
     lineLiq + '\n' +
     lineAct + '\n' +
     lineAvg + '\n' +
     lineBatch + '\n' +
     lineCheck + '\n' +
     '\n' +
     lineBalance + '\n' +
     lineIntensity + '\n' +
     lineQuality + '\n' +
     lineCoercion + '\n' +
     lineOverrides + '\n' +
     lineClassification + '\n' +
     lineEvents + '\n' +
     '\n' +
     protocol;

   out[i][0] = block;
 }

 // запись отчётов
 sh.getRange(r1, idx[HDRS.REPORT], nRows, 1).setValues(out);
 sh.getRange(r1, idx[HDRS.REPORT], nRows, 1).setWrap(true);
}

/** === ВСПОМОГАТЕЛЬНЫЕ === **/
function locate_(sheet, names) {
 const head = sheet.getRange(HEADER_ROW, 1, 1, sheet.getLastColumn()).getValues()[0];
 const norm = s => String(s||'').trim().toLowerCase();
 const want = {}; names.forEach(n => { if (n) want[norm(n)] = n; });
 const idx = {};
 for (let c=0; c<head.length; c++) {
   const h = norm(head[c]);
   if (want[h] && !idx[want[h]]) idx[want[h]] = c + 1;
 }
 return idx;
}
const isNum = v => typeof v === 'number' && isFinite(v);
const fmt2 = n => (typeof n === 'number' ? n.toFixed(2) : String(n));
const fmt1 = n => (typeof n === 'number' ? n.toFixed(1) : String(n));

// локализованный формат «2 знака, запятая, пробелы по-русски»
const fmt2ru = n => {
 if (typeof n !== 'number' || !isFinite(n)) return String(n);
 // сначала форматируем с запятой и пробелами по-русски
 const s = n.toLocaleString('ru-RU', {minimumFractionDigits:2, maximumFractionDigits:2});
 // заменяем запятую обратно на точку
 return s.replace(',', '.');
};

// Формат даты под протокол: 04.11.2025.13.00 (без дня недели, без GMT/таймзоны)
function fmtDate(value) {
 const tz = SpreadsheetApp.getActive().getSpreadsheetTimeZone();
 const PATTERN = 'dd.MM.yyyy HH:mm';  // <-- тут правильный формат!

 if (value instanceof Date) {
   return Utilities.formatDate(value, tz, PATTERN);
 }

 if (typeof value === 'number' && isFinite(value)) {
   return Utilities.formatDate(new Date(value), tz, PATTERN);
 }

 if (typeof value === 'string') {
   const s = value.trim();
   const d = new Date(s);
   if (!isNaN(d.getTime())) {
     return Utilities.formatDate(d, tz, PATTERN);
   }
   return s;
 }

 return String(value || '');
}


// имплицитная цена: 0 знаков и пробелы по-русски
const fmt0 = n => (typeof n === 'number'
 ? n.toLocaleString('ru-RU', {maximumFractionDigits:0, minimumFractionDigits:0})
 : String(n));

function fmtKMB(n, d = 2) {
 if (typeof n !== 'number' || !isFinite(n)) return String(n);
 const abs = Math.abs(n);
 if (abs >= 1e9) return (n / 1e9).toFixed(d) + 'B';
 if (abs >= 1e6) return (n / 1e6).toFixed(d) + 'M';
 if (abs >= 1e3) return (n / 1e3).toFixed(d) + 'K';
 return n.toFixed(d);
}
const ui_ = m => SpreadsheetApp.getUi().alert(m);

function fmtSignedPct1(x) {
 if (!(typeof x === 'number' && isFinite(x))) return 'N/A';
 const val = x;
 const s = val.toFixed(1);
 return (val > 0 ? '+' : (val < 0 ? '−' : '')) + s.replace('-', '') + '%';
}


kompozit.gs

/** ============= kompozit.gs ============= **/
function makeKompozitForSelection() {
 /** === ЛОКАЛЬНЫЕ НАСТРОЙКИ / КОЛОНКИ (без глобалей) === **/
 const HEADER_ROW = 1;
 const TARGET_HEADER_KOMPOZIT = 'Композит';

 // точные заголовки (регистр не важен)
 const HDRK = {
   TIME: 'time',
   TF: 'TF',
   EXCHANGE: 'Биржа',
   INSTR: 'Инструмент',        // формат: ETHUSDT Perp
   O: 'O', H: 'H', L: 'L', C: 'C', V: 'V',
   HL: 'H−L',
   ABV_B: 'ABV_Buy',
   ABV_S: 'ABV_Sell',          // модуль
   ABV_D: 'ABV_Delta',
   TR_B: 'Trades_Buy',
   TR_S: 'Trades_Sell',        // модуль
   TR_D: 'Trades_Delta',
   DOI: 'ΔOI_%',               // уже посчитан, в %
   OI_O: 'OI_O',
   OI_C: 'OI_C',
   LQ_L: 'Liq_Long',
   LQ_S: 'Liq_Short',
   REPORT: TARGET_HEADER_KOMPOZIT
 };

 // пороги из ТЗ
 const THRESH = {
   CVD: 1.0,   // %
   TR:  0.5,   // %
   TILT: 2.0,  // %
   DOI: 0.5,   // %
   LIQ_V_HIGH: 0.30, // %
   LIQ_V_LOW:  0.10  // %
 };

 /** === ЛОКАЛЬНЫЕ ХЕЛПЕРЫ (внутри функции) === **/
 const ui = m => SpreadsheetApp.getUi().alert(m);
 const isNum = v => typeof v === 'number' && isFinite(v);
 const numOrNull = v => (typeof v === 'number' && isFinite(v)) ? v : null;
 const sumSafe = (a,b) => (isNum(a)?a:0) + (isNum(b)?b:0);
 const fmt1 = n => (typeof n==='number'? n.toFixed(2) : 'N/A');
 const valPct = x => (typeof x==='number' && isFinite(x)) ? (fmt1(x) + '%') : 'N/A';
 const signByThresh = (x, thr) => (!isNum(x) ? 0 : (x >= thr ? +1 : (x <= -thr ? -1 : 0)));
 const signChar = s => s>0?'+':(s<0?'-':'0');
 const signGlyph = s => s>0?'(+)':(s<0?'(−)':'(0)');
 const signExplain = (sign, isNA) => {
 if (isNA) return 'N/A';
 return sign > 0 ? 'положительный' : (sign < 0 ? 'отрицательный' : 'нейтральный');
 };
 const uniq = arr => Array.from(new Set(arr));
 const normalizeDateKey = v => {
   if (v instanceof Date) return v.getTime();
   if (typeof v === 'number') return v;
   const d = new Date(String(v||'').trim());
   return isNaN(d.getTime()) ? String(v||'') : d.getTime();
 };
 const vWeighted = (arr, w) => {
   let s=0, ws=0;
   for (let i=0;i<arr.length;i++){
     const x = arr[i];
     if (isNum(x)) { s += x * (w[i]||0); ws += (w[i]||0); }
   }
   // нормализация на сумму фактических весов
   return ws>0 ? (s / ws) : null;
 };
 const dispersion = (values, thr) => {
   const vs = values.filter(isNum);
   if (!vs.length) return 'N/A';
   const signs = vs.map(v=>signByThresh(v,thr));
   const hasPos = signs.some(s=>s>0);
   const hasNeg = signs.some(s=>s<0);
   const allWithin = vs.every(v=>Math.abs(v)<=thr);
   return (hasPos && hasNeg && allWithin) ? 'смешанный' : 'ок';
 };

 // Итог по 3-шаговому правилу (CVD/ΔOI, затем CLV)
 function finalBy3Step(cvdSign, doiSign, clv) {
   // Шаг 1: одинаковое направление CVD и ΔOI
   if (cvdSign > 0 && doiSign > 0) return 'покупатель';
   if (cvdSign < 0 && doiSign < 0) return 'продавец';
   // Шаг 2: уточнение по CLV
   if (typeof clv === 'number') {
     if (clv > 70) return 'покупатель'; // принятие сверху
     if (clv < 30) return 'продавец';   // принятие снизу
   }
   // Шаг 3: иначе нейтрально
   return 'нейтрально';
 }

 const locateLocal_ = (sheet, names) => {
   const head = sheet.getRange(HEADER_ROW, 1, 1, sheet.getLastColumn()).getValues()[0];
   const norm = s => String(s||'').trim().toLowerCase();
   const want = {}; names.forEach(n => { if (n) want[norm(n)] = n; });
   const idx = {};
   for (let c=0; c<head.length; c++) {
     const h = norm(head[c]);
     if (want[h] && !idx[want[h]]) idx[want[h]] = c + 1;
   }
   return idx;
 };

 /** === ОСНОВНОЙ КОД === **/
 const sh  = SpreadsheetApp.getActiveSheet();
 const sel = sh.getActiveRange();
 if (!sel) return ui('Выдели 2–4 строки со свечами разных бирж одной и той же даты/TF.');

 const idx = locateLocal_(sh, Object.values(HDRK));
 const need = [HDRK.TIME, HDRK.TF, HDRK.EXCHANGE, HDRK.INSTR, HDRK.O, HDRK.H, HDRK.L, HDRK.C, HDRK.V, HDRK.REPORT];
 if (!need.every(h => idx[h])) {
   return ui('Проверь заголовки: нужны как минимум time, TF, Биржа, Инструмент, O,H,L,C,V и «Композит».');
 }

 const r1 = Math.max(sel.getRow(), HEADER_ROW + 1);
 const r2 = sel.getLastRow();
 const nRows = r2 - r1 + 1;
 if (nRows < 2 || nRows > 4) return ui('По ТЗ выделение должно быть 2–4 строки.');

 const lastCol = sh.getLastColumn();
 const Vals = sh.getRange(r1, 1, nRows, lastCol).getValues();
 const at = (row, name) => (idx[name] ? row[idx[name]-1] : undefined);

 // собрать строки
 const rows = Vals.map(row => ({
   row,
   time: at(row, HDRK.TIME),
   tf: String(at(row, HDRK.TF) || '').trim(),
   exch: String(at(row, HDRK.EXCHANGE) || '').trim(),
   instr: String(at(row, HDRK.INSTR) || '').trim(),
   O: numOrNull(at(row, HDRK.O)),
   H: numOrNull(at(row, HDRK.H)),
   L: numOrNull(at(row, HDRK.L)),
   C: numOrNull(at(row, HDRK.C)),
   V: numOrNull(at(row, HDRK.V)),
   HL: numOrNull(at(row, HDRK.HL)),
   ABV_B: numOrNull(at(row, HDRK.ABV_B)),
   ABV_S: numOrNull(at(row, HDRK.ABV_S)), // модуль
   ABV_D: numOrNull(at(row, HDRK.ABV_D)),
   TR_B:  numOrNull(at(row, HDRK.TR_B)),
   TR_S:  numOrNull(at(row, HDRK.TR_S)),  // модуль
   TR_D:  numOrNull(at(row, HDRK.TR_D)),
   DOI_col: numOrNull(at(row, HDRK.DOI)),
   OI_O: numOrNull(at(row, HDRK.OI_O)),
   OI_C: numOrNull(at(row, HDRK.OI_C)),
   LL: numOrNull(at(row, HDRK.LQ_L)),
   LS: numOrNull(at(row, HDRK.LQ_S))
 }));

 // === Проверка модулей: должны быть ≥ 0 (иначе — ошибка входа) ===
 const negIssues = [];
 rows.forEach((r, i) => {
   const bad = [];
   if (isNum(r.ABV_S) && r.ABV_S < 0) bad.push('ABV_Sell');
   if (isNum(r.TR_S)  && r.TR_S  < 0) bad.push('Trades_Sell');
   if (isNum(r.LL)    && r.LL    < 0) bad.push('Liq_Long');
   if (isNum(r.LS)    && r.LS    < 0) bad.push('Liq_Short');
   if (bad.length) {
     const where = r.exch ? `${r.exch}` : `строка ${r1 + i}`;
     negIssues.push(`${where}: ${bad.join(', ')} < 0`);
   }
 });
 if (negIssues.length) {
   return ui(
     'Ошибка нормализации модулей (эти колонки должны быть ≥ 0):\n' +
     negIssues.join('\n') +
     '\nИсправь значения в данных (Sell/Short должны быть модулем).'
   );
 }

 // проверки TF/инструмент/время
 const tfSet = uniq(rows.map(r=>r.tf));
 const instrSet = uniq(rows.map(r=>r.instr));
 const timeSet = uniq(rows.map(r=>normalizeDateKey(r.time)));

 const errs = [];
 if (tfSet.length !== 1) errs.push('TF: ' + tfSet.join(' vs '));
 if (instrSet.length !== 1) errs.push('инструмент: ' + instrSet.join(' vs '));
 if (timeSet.length !== 1) errs.push('время: различается');
 if (errs.length) return ui('Ошибка входа: несоответствие параметров → ' + errs.join('; '));

 // пер-биржевые метрики
 const per = rows.map(r => {
   const range = isNum(r.HL) ? r.HL : (isNum(r.H)&&isNum(r.L) ? (r.H - r.L) : null);

   let cvdPct = null;
   const activeVol = sumSafe(r.ABV_B, r.ABV_S);
   if (isNum(activeVol) && activeVol !== 0 && isNum(r.ABV_D)) cvdPct = (r.ABV_D / activeVol) * 100;

   let trPct = null;
   const trTot = sumSafe(r.TR_B, r.TR_S);
   if (isNum(r.TR_B) && isNum(r.TR_S) && trTot !== 0) trPct = ((r.TR_B - r.TR_S) / trTot) * 100;
   else if (isNum(r.TR_D) && trTot !== 0) trPct = (r.TR_D / trTot) * 100;

   let tiltPct = null;
   if (isNum(r.ABV_B) && isNum(r.TR_B) && r.TR_B!==0 && isNum(r.ABV_S) && isNum(r.TR_S) && r.TR_S!==0) {
     const avgBuy = r.ABV_B / r.TR_B;
     const avgSell = r.ABV_S / r.TR_S;
     if (avgBuy > 0) tiltPct = ((avgSell/avgBuy) - 1) * 100;
   }

   let doiPct = isNum(r.DOI_col) ? r.DOI_col : null;
   if (doiPct==null && isNum(r.OI_O) && isNum(r.OI_C) && r.OI_O!==0) {
     doiPct = ((r.OI_C - r.OI_O)/r.OI_O)*100;
   }

   let liqShare = null;
   if (isNum(r.V) && r.V!==0 && isNum(r.LL) && isNum(r.LS)) {
     liqShare = ((r.LL + r.LS)/r.V) * 100;
   }

   let clv=null, upper=null, lower=null, body=null;
   if (isNum(range) && range>0 && [r.O,r.H,r.L,r.C].every(isNum)) {
     clv   = ((r.C - r.L)/range)*100;
     upper = ((r.H - Math.max(r.O, r.C))/range)*100;
     lower = ((Math.min(r.O, r.C) - r.L)/range)*100;
     body  = (Math.abs(r.C - r.O)/range)*100;
   }

   return {exch:r.exch, V:r.V||0, cvdPct, trPct, tiltPct, doiPct, liqShare, LL:r.LL||0, LS:r.LS||0, clv, upper, lower, body};
 });

 // веса по V
 const sumV = per.reduce((a,b)=>a + (isNum(b.V)?b.V:0), 0);
 const w = per.map(p => (isNum(p.V) && sumV>0) ? (p.V/sumV) : 0);

 // композиты
 const comp = {
   cvd:  vWeighted(per.map(p=>p.cvdPct), w),
   tr:   vWeighted(per.map(p=>p.trPct),  w),
   tilt: vWeighted(per.map(p=>p.tiltPct),w),
   doi:  vWeighted(per.map(p=>p.doiPct), w),
   liq:  vWeighted(per.map(p=>p.liqShare), w),
   clv:   vWeighted(per.map(p=>p.clv),   w),
   upper: vWeighted(per.map(p=>p.upper), w),
   lower: vWeighted(per.map(p=>p.lower), w),
   body:  vWeighted(per.map(p=>p.body),  w)
 };

 // ликвидации доминирование
 const sumLL = per.reduce((a,b)=>a + (isNum(b.LL)?b.LL:0), 0);
 const sumLS = per.reduce((a,b)=>a + (isNum(b.LS)?b.LS:0), 0);
 const liqTilt = sumLL>sumLS ? 'Long доминируют' : (sumLL<sumLS ? 'Short доминируют' : 'сбалансировано');

 const clvInterp = comp.clv==null
   ? 'N/A'
   : (comp.clv>=70 ? 'принятие сверху'
     : (comp.clv<=30 ? 'принятие снизу' : 'середина диапазона'));

 // знаки/дисперсии
 const cvdSign = signByThresh(comp.cvd, THRESH.CVD);
 const trSign  = signByThresh(comp.tr,  THRESH.TR);
 const doiSign = signByThresh(comp.doi, THRESH.DOI);
 const tiltInterpret = comp.tilt==null ? 'N/A'
                       : (comp.tilt>=THRESH.TILT ? 'sell тяжелее'
                         : (comp.tilt<=-THRESH.TILT ? 'buy тяжелее' : 'нейтр'));
 const liqEval = comp.liq==null ? 'N/A'
                  : (comp.liq>THRESH.LIQ_V_HIGH ? 'ведут ликвидации'
                    : (comp.liq<=THRESH.LIQ_V_LOW ? 'фон' : 'умеренно'));
 const dispCVD = dispersion(per.map(p=>p.cvdPct), THRESH.CVD);
 const dispDOI = dispersion(per.map(p=>p.doiPct), THRESH.DOI);

 const instr = rows[0].instr;
 const tf    = rows[0].tf;
 const nExch = per.length;
 const exchList = per.map(p => p.exch).join(', '); // "Binance, OKX, Bybit"

 const perTrades = per.map(p =>
   p.trPct==null
     ? `${p.exch} N/A`
     : `${p.exch} ${fmt1(p.trPct)}% ${signGlyph(signByThresh(p.trPct, THRESH.TR))}`
 ).join('; ');
 const perCVD = per.map(p =>
   p.cvdPct==null ? `${p.exch} N/A`
                  : `${p.exch} ${fmt1(p.cvdPct)}% ${signGlyph(signByThresh(p.cvdPct, THRESH.CVD))}`
 ).join('; ');
 const perDOI = per.map(p =>
   p.doiPct==null ? `${p.exch} N/A`
                  : `${p.exch} ${fmt1(p.doiPct)}% ${signGlyph(signByThresh(p.doiPct, THRESH.DOI))}`
 ).join('; ');

 const finalMark = finalBy3Step(cvdSign, doiSign, comp.clv);
 const clvAccept =
   (typeof comp.clv === 'number')
     ? (comp.clv > 70 ? ' (принятие сверху)' : (comp.clv < 30 ? ' (принятие снизу)' : ''))
     : '';

 let finalEmoji = '';
 if (finalMark === 'покупатель') finalEmoji = '🟢 ';
 else if (finalMark === 'продавец') finalEmoji = '🔴 ';


 const cvdExplain = signExplain(cvdSign, comp.cvd == null);
 const doiExplain = signExplain(doiSign, comp.doi == null);


 const report =
`КОМПОЗИТНАЯ СВОДКА
• Инструмент/TF: ${instr} / ${tf} • Биржи: ${nExch} (${exchList})

1) CVD (дельта активного объёма):
  - Композит: ${valPct(comp.cvd)} , знак: ${comp.cvd==null ? 'N/A' : signChar(cvdSign)} [дисперсия: ${dispCVD}]
  - По биржам: ${perCVD}
2) Δ по числу сделок (Trades):
  - Композит: ${valPct(comp.tr)} , знак: ${comp.tr==null  ? 'N/A' : signChar(trSign)}
  - По биржам: ${perTrades}
3) Перекос среднего размера сделки (Tilt, sell vs buy):
  - Композит: ${valPct(comp.tilt)} , интерпретация: ${tiltInterpret}
4) Ликвидации:
  - Доля: ${valPct(comp.liq)} • Перекос: ${liqTilt} • Оценка: ${liqEval}
5) Open Interest:
  - Композит ΔOI%: ${valPct(comp.doi)} , знак: ${comp.doi==null ? 'N/A' : signChar(doiSign)} [дисперсия: ${dispDOI}]
  - По биржам: ${perDOI}
6) Объёмный режим (V vs медиана 5 свечей): N/A
7) Геометрия свечи:
  - CLV: ${valPct(comp.clv)} (${clvInterp})
  - Тени: верхняя ${valPct(comp.upper)} / нижняя ${valPct(comp.lower)}
  - Тело: ${valPct(comp.body)}

${finalEmoji}Итог: ${finalMark}, аргументы: CVD ${signChar(cvdSign)} (${cvdExplain}), ΔOI ${signChar(doiSign)} (${doiExplain}), CLV ${valPct(comp.clv)}${clvAccept}, ликвидации: ${liqEval}, перекос: ${liqTilt}.`;



 // === Записываем ОДНУ ячейку — верхняя строка выделения ===
 if (!idx[HDRK.REPORT]) return ui('Не найдена колонка «Композит». Добавь её в шапку.');
 sh.getRange(r1, idx[HDRK.REPORT], 1, 1).setValue(report);
 sh.getRange(r1, idx[HDRK.REPORT], 1, 1).setWrap(true);

}


x-ray.gs

/**
* zero-calc.gs
* Генерирует отчет Zero-calc в формате: метрика: значение
*/

const ZERO_CALC_REPORT_COL = 'X-RAY';

// 🔹 ПОРЯДОК И МАППИНГ КОЛОНОК
const ZERO_CALC_MAP = {
 ts: 'time',
 exchange: 'Биржа',
 symbol: 'Инструмент',
 tf: 'TF',

 open: 'O',
 high: 'H',
 low: 'L',
 close: 'C',
 volume: 'V',

 buy_volume: 'ABV_Buy',
 sell_volume: 'ABV_Sell',
 buy_trades: 'Trades_Buy',
 sell_trades: 'Trades_Sell',

 oi_open: 'OI_O',
 oi_high: 'OI_H',
 oi_low: 'OI_L',
 oi_close: 'OI_C',

 liq_long: 'Liq_Long',
 liq_short: 'Liq_Short',

 range: 'H−L',
 body_pct: 'Body_%',
 clv_pct: 'CLV п.п.',
 upper_tail_pct: 'upper_tail_pct',
 lower_tail_pct: 'lower_tail_pct',
 price_sign: 'price_sign',
 dominant_reject: 'dominant_reject',

 cvd_pct: 'cvd_pct',
 cvd_sign: 'cvd_sign',
 cvd_small: 'cvd_small',
 dpx: 'dpx_2',
 price_vs_delta: 'price_vs_delta',

 dtrades_pct: 'Trades_Ratio',
 ratio_stable: 'ratio_stable',
 tilt_pct: 'Tilt%',

 doi_pct: 'ΔOI_%',
 oi_in_sens: 'oi_in_sens',
 oi_set: 'oi_set',
 oi_counter: 'oi_counter',
 oi_unload: 'oi_unload',
 oipos: 'OIpos',
 oi_path: 'oi_path',
 oe: 'oe_modul',

 liqshare_pct: 'LiqShare п.п.',
 limb_pct: 'Limb%',
 liq_squeeze: 'liq_squeeze',

 range_pct: 'Range%',
 implied_price: 'Имплицитная_цена',

 avg_trade_buy: 'Avg_trade _Buy',
 avg_trade_sell: 'Avg_trade_Sell'
};

function makeZeroCalcForSelection() {
 const ss = SpreadsheetApp.getActiveSpreadsheet();
 const sheet = ss.getActiveSheet();
 const selection = sheet.getActiveRange();
  const headerRow = sheet.getRange(1, 1, 1, sheet.getMaxColumns()).getValues()[0];
 const headerMap = {};
 for (let i = 0; i < headerRow.length; i++) {
   headerMap[headerRow[i]] = i;
 }
  let zeroCalcCol = headerMap[ZERO_CALC_REPORT_COL];
 if (zeroCalcCol === undefined) {
   SpreadsheetApp.getUi().alert('Колонка X-RAY не найдена!');
   return;
 }
 zeroCalcCol++;
  const rows = selection.getRow();
 const numRows = selection.getNumRows();
  for (let r = 0; r < numRows; r++) {
   const rowNum = rows + r;
   const rowData = sheet.getRange(rowNum, 1, 1, sheet.getMaxColumns()).getValues()[0];
  
   const data = {};
   for (const [metricName, colName] of Object.entries(ZERO_CALC_MAP)) {
     const colIdx = headerMap[colName];
     if (colIdx !== undefined) {
       data[metricName] = rowData[colIdx];
     }
   }
  
   const report = buildZeroCalcReport_(data);
   sheet.getRange(rowNum, zeroCalcCol).setValue(report);
 }
 }

function buildZeroCalcReport_(data) {
 const lines = [];

 // метрики, которые выводим как проценты
 const PCT_METRICS = [
   'body_pct',
   'clv_pct',
   'upper_tail_pct',
   'lower_tail_pct',
   'cvd_pct',
   'dtrades_pct',
   'doi_pct',
   'liqshare_pct',
   'limb_pct',
   'oipos',
   'tilt_pct',
   'range_pct'
 ];

 // большие десятичные: цены, средний трейд
 const BIG_DEC_METRICS = [
   'open',
   'high',
   'low',
   'close',
   'implied_price',
   'avg_trade_buy',
   'avg_trade_sell'
 ];

 // большие целые: объёмы, OI, ликвидации
 const BIG_INT_METRICS = [
   'volume',
   'buy_volume',
   'sell_volume',
   'buy_trades',
   'sell_trades',
   'oi_open',
   'oi_high',
   'oi_low',
   'oi_close',
   'liq_long',
   'liq_short'
 ];
  for (const [metricName] of Object.entries(ZERO_CALC_MAP)) {
   let value = data[metricName];
  
   if (value === '' || value === null || value === undefined) {
     value = '−';
   } else {
     if (metricName === 'ts') {
       value = fmtDate_(value);
     } else if (PCT_METRICS.includes(metricName)) {
       value = fmt2_(value);
       if (value !== '−') value += '%';
     } else if (['range', 'oe', 'dpx'].includes(metricName)) {
       // просто 2 знака, без разделения тысяч
       value = fmt2_(value);
     } else if (BIG_DEC_METRICS.includes(metricName)) {
       // цены/средний трейд: пробелы по тысячам, 2 знака
       value = fmtBig_(value, 2);
     } else if (BIG_INT_METRICS.includes(metricName)) {
       // объёмы/счётчики: пробелы по тысячам, без знаков после запятой
       value = fmtBig_(value, 0);
     } else {
       value = String(value);
     }
   }
  
   lines.push(metricName + ': ' + value);
 }
  return lines.join('\n');
}

// 2 знака, запятая как разделитель, без тысячных (для диапазонов и т.п.)
function fmt2_(val) {
 if (val === '' || val === null || val === undefined) return '−';
  let strVal = String(val).trim();
 strVal = strVal.replace(/,/g, '.');
  const numVal = Number(strVal);
 if (isNaN(numVal)) return String(val);
  const formatted = (Math.round(numVal * 100) / 100).toFixed(2);
 return formatted.replace('.', ',');
}

// большие числа: пробелы для тысяч, ru-RU, настраиваем кол-во знаков
function fmtBig_(val, decimals) {
 if (val === '' || val === null || val === undefined) return '−';
  let strVal = String(val).trim();
 strVal = strVal.replace(/,/g, '.');
  const numVal = Number(strVal);
 if (isNaN(numVal)) return String(val);
  return numVal.toLocaleString('ru-RU', {
   minimumFractionDigits: decimals,
   maximumFractionDigits: decimals
 });
}

// дата как было
function fmtDate_(val) {
 if (!val) return '−';
 const date = new Date(val);
 if (isNaN(date.getTime())) return val.toString();
  const day = String(date.getDate()).padStart(2, '0');
 const month = String(date.getMonth() + 1).padStart(2, '0');
 const year = date.getFullYear();
 const hours = String(date.getHours()).padStart(2, '0');
 const minutes = String(date.getMinutes()).padStart(2, '0');
  return day + '.' + month + '.' + year + ' ' + hours + ':' + minutes;
}



levels.gs

function makeLevelsForSelection() {
 const ss = SpreadsheetApp.getActive();
 const sheet = ss.getSheetByName('свечи');
 const metaSheet = ss.getSheetByName('d_4h_porogi');
 if (!sheet || !metaSheet) {
   SpreadsheetApp.getUi().alert('Не найден лист "свечи" или "d_4h_porogi".');
   return;
 }

 const range = sheet.getActiveRange();
 if (!range) {
   SpreadsheetApp.getUi().alert('Сначала выдели строки на листе "свечи".');
   return;
 }

 const startRow = range.getRow();
 const numRows = range.getNumRows();

 // Заголовки и "Уровни" колонка на листе "свечи"
 const lastCol = sheet.getLastColumn();
 const headerRow = sheet.getRange(1, 1, 1, lastCol).getValues()[0];

 const idxLevelsCol = headerRow.indexOf('Уровни');
 if (idxLevelsCol === -1) {
   SpreadsheetApp.getUi().alert('Не найдена колонка "Уровни" в строке заголовков.');
   return;
 }

 // Колонка инструмента (пробуем "Инструмент", если нет — "text")
 let idxSymbolCol = headerRow.indexOf('Инструмент');
 if (idxSymbolCol === -1) {
   idxSymbolCol = headerRow.indexOf('text');
 }
 if (idxSymbolCol === -1) {
   SpreadsheetApp.getUi().alert('Не найдена колонка "Инструмент" (или "text").');
   return;
 }

 // tf_metadata из d_4h_porogi
 const metaLastCol = metaSheet.getLastColumn();
 const metaHeaders = metaSheet.getRange(1, 1, 1, metaLastCol).getValues()[0];
 const metaValuesDisplay = metaSheet.getRange(2, 1, 1, metaLastCol).getDisplayValues()[0];

 function getMeta(name) {
   const idx = metaHeaders.indexOf(name);
   return idx === -1 ? '' : metaValuesDisplay[idx];
 }

 // Хелпер: индекс по имени (с альтернативами)
 function colIndex(nameOrArray) {
   const names = Array.isArray(nameOrArray) ? nameOrArray : [nameOrArray];
   for (let i = 0; i < names.length; i++) {
     const idx = headerRow.indexOf(names[i]);
     if (idx !== -1) return idx;
   }
   return -1;
 }

 // Индексы всех колонок для блока candles
 const idxMap = {
   ts:            colIndex('time'),
   tf:            colIndex('TF'),
   open:          colIndex('O'),
   high:          colIndex('H'),
   low:           colIndex('L'),
   close:         colIndex('C'),
   range:         colIndex(['H−L','H-L']),
   range_pct:     colIndex('Range%'),
   body_pct:      colIndex('Body_%'),
   clv_pct:       colIndex('CLV п.п.'),
   upper_tail:    colIndex('upper_tail_pct'),
   lower_tail:    colIndex('lower_tail_pct'),
   price_sign:    colIndex('price_sign'),
   cvd_pct:       colIndex('cvd_pct'),
   cvd_small:     colIndex('cvd_small'),
   cvd_sign:      colIndex('cvd_sign'),
   doi_pct:       colIndex('ΔOI_%'),
   ratio_stable:  colIndex('ratio_stable'),
   liqshare_pct:  colIndex('LiqShare п.п.'),
   dpx:           colIndex('dpx_2'),
   price_vs_delta:colIndex('price_vs_delta'),
   geo_score:     colIndex('geo_score'),
   flow_score:    colIndex('flow_score'),
   liq_penalty:   colIndex('liq_penalty'),
   rq_calc:       colIndex('rq_calculated')
 };

 function cell(rowDisplay, idx) {
   return idx === -1 ? '' : rowDisplay[idx];
 }

 // 🔹 Нормализация таймфрейма в формат H4/D1/M30/W1/H1/M15/M5
 function normalizeTf(tfRaw) {
   const tf = String(tfRaw || '').trim().toUpperCase(); // "1d" → "1D", "30m" → "30M"
   if (!tf) return '';

   // Вариант "1D", "4H", "30M", "1W" → "D1", "H4", "M30", "W1"
   let m = tf.match(/^(\d+)\s*([HDWM])$/);
   if (m) return m[2] + m[1];

   // Вариант уже "D1", "H4", "M30", "W1" → просто нормализуем регистр
   m = tf.match(/^([HDWM])\s*(\d+)$/);
   if (m) return m[1] + m[2];

   // Если формат какой-то свой — возвращаем как есть, но в верхнем регистре
   return tf;
 }

 // Инструмент берём из первой выделенной строки
 const firstRowValues = sheet.getRange(startRow, 1, 1, lastCol).getDisplayValues()[0];
 const symbol = firstRowValues[idxSymbolCol];

 const lines = [];

 // --- symbol ---
 lines.push('symbol: ' + symbol);
 lines.push('');

 // --- tf_metadata ---
 lines.push('tf_metadata:');
 lines.push('  W1:');
 lines.push('    rv_pct: '          + getMeta('rv_tf_1w'));
 lines.push('    atr_abs: '         + getMeta('atr_1w'));
 lines.push('    vol_k: '           + getMeta('vol_k_1w'));
 lines.push('    sens_adapt: '      + getMeta('sens_adapt_1w'));
 lines.push('    width_pct: '       + getMeta('width_pct_1w'));
 lines.push('    width_abs: '       + getMeta('width_abs_1w'));
 lines.push('    last_close_price: '+ getMeta('last_close_1w'));
 lines.push('');
 lines.push('  D1:');
 lines.push('    rv_pct: '          + getMeta('rv_tf_1d'));
 lines.push('    atr_abs: '         + getMeta('atr_1d'));
 lines.push('    vol_k: '           + getMeta('vol_k_1d'));
 lines.push('    sens_adapt: '      + getMeta('sens_adapt_1d'));
 lines.push('    width_pct: '       + getMeta('width_pct_1d'));
 lines.push('    width_abs: '       + getMeta('width_abs_1d'));
 lines.push('    last_close_price: '+ getMeta('last_close_1d'));
 lines.push('');
 lines.push('  H4:');
 lines.push('    rv_pct: '          + getMeta('rv_tf_4h'));
 lines.push('    atr_abs: '         + getMeta('atr_4h'));
 lines.push('    vol_k: '           + getMeta('vol_k_4h'));
 lines.push('    sens_adapt: '      + getMeta('sens_adapt_4h'));
 lines.push('    width_pct: '       + getMeta('width_pct_4h'));
 lines.push('    width_abs: '       + getMeta('width_abs_4h'));
 lines.push('    last_close_price: '+ getMeta('last_close_4h'));
 lines.push('');

 // --- candles ---
 lines.push('candles:');

 for (let i = 0; i < numRows; i++) {
   const row = startRow + i;
   const rowDisplay = sheet.getRange(row, 1, 1, lastCol).getDisplayValues()[0];

   const rawTf  = cell(rowDisplay, idxMap.tf);
   const normTf = normalizeTf(rawTf);   // ← используем нормализованное значение

   lines.push('  - ts: ' + cell(rowDisplay, idxMap.ts));
   lines.push('    tf: ' + normTf);
   lines.push('    open: ' + cell(rowDisplay, idxMap.open));
   lines.push('    high: ' + cell(rowDisplay, idxMap.high));
   lines.push('    low: ' + cell(rowDisplay, idxMap.low));
   lines.push('    close: ' + cell(rowDisplay, idxMap.close));
   lines.push('    range: ' + cell(rowDisplay, idxMap.range));
   lines.push('    range_pct: ' + cell(rowDisplay, idxMap.range_pct));
   lines.push('    body_pct: ' + cell(rowDisplay, idxMap.body_pct));
   lines.push('    clv_pct: ' + cell(rowDisplay, idxMap.clv_pct));
   lines.push('    upper_tail_pct: ' + cell(rowDisplay, idxMap.upper_tail));
   lines.push('    lower_tail_pct: ' + cell(rowDisplay, idxMap.lower_tail));
   lines.push('    price_sign: ' + cell(rowDisplay, idxMap.price_sign));
   lines.push('    cvd_pct: ' + cell(rowDisplay, idxMap.cvd_pct));
   lines.push('    cvd_small: ' + cell(rowDisplay, idxMap.cvd_small));
   lines.push('    cvd_sign: ' + cell(rowDisplay, idxMap.cvd_sign));
   lines.push('    doi_pct: ' + cell(rowDisplay, idxMap.doi_pct));
   lines.push('    ratio_stable: ' + cell(rowDisplay, idxMap.ratio_stable));
   lines.push('    liqshare_pct: ' + cell(rowDisplay, idxMap.liqshare_pct));
   lines.push('    dpx: ' + cell(rowDisplay, idxMap.dpx));
   lines.push('    price_vs_delta: ' + cell(rowDisplay, idxMap.price_vs_delta));
   lines.push('    geo_score: ' + cell(rowDisplay, idxMap.geo_score));
   lines.push('    flow_score: ' + cell(rowDisplay, idxMap.flow_score));
   lines.push('    liq_penalty: ' + cell(rowDisplay, idxMap.liq_penalty));
   lines.push('    rq_calculated: ' + cell(rowDisplay, idxMap.rq_calc));
 }

 const reportText = lines.join('\n');

 // Записываем в первую выделенную строку, в колонку "Уровни"
 sheet.getRange(startRow, idxLevelsCol + 1).setValue(reportText);
}

function debugPorogiRows() {
 const ss = SpreadsheetApp.getActive();
 const sh = ss.getSheetByName('d_4h_porogi');
 if (!sh) {
   SpreadsheetApp.getUi().alert('Лист d_4h_porogi не найден');
   return;
 }

 const maxRows = sh.getMaxRows();
 const lastRow = sh.getLastRow();

 SpreadsheetApp.getUi().alert(
   'd_4h_porogi:\n' +
   'Макс. строк (getMaxRows): ' + maxRows + '\n' +
   'Последняя заполненная (getLastRow): ' + lastRow
 );
}




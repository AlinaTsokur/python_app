import math
import re
from datetime import datetime, timedelta
from statistics import mean, stdev
from collections import Counter

# --- HELPER FUNCTIONS ---
def sign(x):
    if x > 0: return 1
    elif x < 0: return -1
    else: return 0

def extract_numeric_value(text, label):
    """
    –ò–∑–≤–ª–µ–∫–∞–µ—Ç —á–∏—Å–ª–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –∏–∑ —Ç–µ–∫—Å—Ç–∞ (—Å %)
    Example: extract_numeric_value("CVD –∫–æ–º–ø–æ–∑–∏—Ç: 5.35%", "–ö–æ–º–ø–æ–∑–∏—Ç") -> 5.35
    """
    if not text: return None
    pattern = rf"{re.escape(label)}.*?([+-]?\d+\.?\d*)%"
    match = re.search(pattern, text, re.IGNORECASE)
    return float(match.group(1)) if match else None



# --- 1. PREPARE LOGIC FLAGS ---
def prepare_logic_flags(m, location_ui):
    """
    –ü—Ä–µ–≤—Ä–∞—â–∞–µ—Ç –≤—ã–±–æ—Ä –≤ UI (–ó–æ–Ω–∞ + –î–µ–π—Å—Ç–≤–∏–µ) –≤ –ª–æ–≥–∏—á–µ—Å–∫–∏–µ —Ñ–ª–∞–≥–∏ –°–µ–∫—Ü–∏–∏ 4.2.
    KB Section 4.2 PATTERNS ‚Üí UI SELECTORS
    """
    # 1. –ü–æ–ª—É—á–∞–µ–º –≤—ã–±–æ—Ä –∏–∑ UI
    ui_zone = location_ui.get('zone', 'Air')           # –∑–Ω–∞—á–µ–Ω–∏–µ —Å–µ–ª–µ–∫—Ç–æ—Ä–∞ 1
    ui_action = location_ui.get('action', 'Hold')      # –∑–Ω–∞—á–µ–Ω–∏–µ —Å–µ–ª–µ–∫—Ç–æ—Ä–∞ 2
    
    # –î–µ—Ñ–æ–ª—Ç–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è
    at_edge = False
    edge_type = "AIR"
    edge_status = "NO_EDGE"

    # ===== –õ–û–ì–ò–ö–ê –°–ï–ö–¶–ò–ò 4.2: –ü–ê–†–°–ò–ù–ì –õ–û–ö–ê–¶–ò–ò =====
    
    # –û–°–ù–û–í–ù–û–ô –ü–ê–¢–¢–ï–†–ù: –ó–æ–Ω–∞ (–æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç at_edge + edge_type)
    if ui_zone == "Air":
        at_edge = False
        edge_type = "AIR"
        edge_status = "NO_EDGE"
        
    elif ui_zone == "Support":
        at_edge = True
        edge_type = "S"
        
    elif ui_zone == "Resistance":
        at_edge = True
        edge_type = "R"
    
    else:
        # –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –∑–æ–Ω—ã ‚Üí –¥–µ—Ñ–æ–ª—Ç (Air)
        at_edge = False
        edge_type = "AIR"
        edge_status = "NO_EDGE"
    
    # –†–ê–°–®–ò–†–ï–ù–ù–´–ô –°–¢–ê–¢–£–°: –î–µ–π—Å—Ç–≤–∏–µ (–æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç edge_status —É —É—Ä–æ–≤–Ω—è)
    # –ü—Ä–∏–º–µ–Ω—è–µ—Ç—Å—è –¢–û–õ–¨–ö–û –µ—Å–ª–∏ at_edge == TRUE
    if at_edge == True:
        if ui_action == "BREAK":
            edge_status = "BREAK"           # KB: "–∑–∞–∫—Ä—ã–ª–∞—Å—å –∑–∞ —É—Ä–æ–≤–Ω–µ–º"
            
        elif ui_action == "PROBE":
            edge_status = "PROBE"           # KB: "–ø—Ä–æ—à–µ–ª —Ç–µ–ª–æ, —Ç–µ–Ω—å –≤–µ—Ä–Ω—É–ª–∞—Å—å"
            
        elif ui_action == "AT_EDGE_BORDERLINE":
            edge_status = "AT_EDGE_BORDERLINE"  # KB: "–Ω–∞ –≥—Ä–∞–Ω–∏—Ü–µ"
            
        elif ui_action == "AT_EDGE_TAIL":
            edge_status = "AT_EDGE_TAIL"    # KB: "—Ç–µ–ª–æ –Ω–∞ —É—Ä–æ–≤–Ω–µ, —Ç–µ–Ω—å –≤—ã—à–µ"
            
        else:  # ui_action == "AT_EDGE" / "Hold" –∏–ª–∏ –¥—Ä—É–≥–æ–µ
            edge_status = "AT_EDGE"         # KB: –±–∞–∑–æ–≤–æ–µ "–ø–æ–¥ R" / "–Ω–∞–¥ S"

    # ===== –û–°–¢–ê–õ–¨–ù–ê–Ø –õ–û–ì–ò–ö–ê (–ë–ï–ó –ò–ó–ú–ï–ù–ï–ù–ò–ô) =====
    
    # SENS now comes strictly from tf_params (t_base in app.py)
    # Strict validation: expect keys to exist (checked by validate_metrics)
    SENS = m.get('tf_sens') 
        
    A_tol = SENS * 0.33
    
    oi_unload = m.get('oi_unload')
    oi_counter = m.get('oi_counter')
    oi_set = m.get('oi_set')
    oi_in_sens = m.get('oi_in_sens', True)
    
    # CVD Noise check
    is_cvd_noise = abs(m.get('cvd_pct', 0) or 0) < (2.0 * SENS / 0.90) if SENS > 0 else False
    
    return {
        "at_edge": at_edge,
        "edge_type": edge_type,
        "edge_status": edge_status,
        
        "sens": SENS,
        "a_tol": A_tol,
        "t_set": m.get('t_set_pct'),      # No default: must exist
        "t_counter": m.get('t_counter_pct'), # No default
        "t_unload": m.get('t_unload_pct'),   # No default
        
        "oi_unload": oi_unload, # No default
        "oi_counter": oi_counter,
        "oi_set": oi_set,
        "oi_in_sens": oi_in_sens,
        
        "is_cvd_noise": is_cvd_noise,
        "liq_threshold": m.get('liq_threshold', 0.30),
        
        # Pass raw UI action for logging if needed, though strictly edge_status is key
        "ui_action": ui_action
    }

# --- 2. CALCULATE AQS ---
def calculate_aqs(m, flags):
    """
    Calculates AQS based on KB Section 4.5
    AQS = (Geometry * 0.50) + (Flow * 0.30) + (OI * 0.20)
    """
    price_sign = m.get('price_sign', 0)
    cvd_sign = m.get('cvd_sign', 0)
    clv = m.get('clv_pct', 50)
    lt = m.get('lower_tail_pct', 0)
    ut = m.get('upper_tail_pct', 0)
    
    # A. Geometry (0.50)
    geom_score = 0.0
    # Optional edge quality mod from dominant_reject (KB 4.4)
    # B. Parsing Dominant Reject (KB 4.4)
    # Corrected to strict nested structure
    edge_quality_mod = 0.0
    dr = m.get('dominant_reject', '-')
    
    if dr is None or dr == '-':
        edge_quality_mod = 0.0
        
    elif 'bull' in str(dr) and ('Valid' in str(dr) or 'Ideal' in str(dr)):
        # –í–ï–†–•–ù–Ø–Ø –¢–ï–ù–¨ (–±—ã—á–∏–π –æ—Ç–∫–∞–∑)
        if price_sign == 1 and cvd_sign == -1:
            edge_quality_mod = 0.05
        else:
            edge_quality_mod = -0.05
            
    elif 'bear' in str(dr) and ('Valid' in str(dr) or 'Ideal' in str(dr)):
        # –ù–ò–ñ–ù–Ø–Ø –¢–ï–ù–¨ (–º–µ–¥–≤–µ–∂–∏–π –æ—Ç–∫–∞–∑)
        if price_sign == -1 and cvd_sign == 1:
            edge_quality_mod = 0.05
        else:
            edge_quality_mod = -0.05

    if price_sign == 1 and cvd_sign == -1: # Long Setup
        # CLV Score
        if clv >= 65: clv_s = 1.0
        elif clv >= 60: clv_s = 0.9
        elif clv >= 55: clv_s = 0.7
        elif clv >= 50: clv_s = 0.5
        else: clv_s = 0.0
        
        # Tail Score
        if lt >= 35: tail_s = 1.0
        elif lt >= 30: tail_s = 0.8
        elif lt >= 25: tail_s = 0.6
        else: tail_s = 0.0
        
        geom_score = (clv_s * 0.6) + (tail_s * 0.4)
        
    elif price_sign == -1 and cvd_sign == 1: # Short Setup
        if clv <= 35: clv_s = 1.0
        elif clv <= 40: clv_s = 0.9
        elif clv <= 45: clv_s = 0.7
        elif clv <= 50: clv_s = 0.5
        else: clv_s = 0.0
        
        if ut >= 35: tail_s = 1.0
        elif ut >= 30: tail_s = 0.8
        elif ut >= 25: tail_s = 0.6
        else: tail_s = 0.0
        
        geom_score = (clv_s * 0.6) + (tail_s * 0.4)
    
    geom_score = max(0.0, min(1.0, geom_score + edge_quality_mod))
    
    # B. Flow Coherence (0.30)
    ratio_s = 1.0 if m.get('ratio_stable') else 0.5
    dtrades = abs(m.get('dtrades_pct', 0) or 0)
    
    if dtrades >= 2.0: dt_s = 1.0
    elif dtrades >= 1.0: dt_s = 0.8
    elif dtrades >= 0.5: dt_s = 0.6
    else: dt_s = 0.3
    
    tilt = m.get('tilt_pct', 0) or 0
    tilt_sign_check = 1.0 if (sign(tilt) == cvd_sign) else 0.5
    
    oe = m.get('oe', 0) or 0
    oe_s = min(oe / 1.5, 1.0)
    
    flow_score = (ratio_s * 0.4) + (dt_s * 0.35) + (tilt_sign_check * 0.15) + (oe_s * 0.10)
    flow_score = max(0.0, min(1.0, flow_score))
    
    # C. OI Cleanliness (0.20)
    doi = abs(m.get('doi_pct', 0) or 0)
    zone_threshold = flags['a_tol'] if flags['at_edge'] else flags['sens']
    
    if doi <= zone_threshold: oi_zone_s = 1.0
    elif doi <= zone_threshold * 2: oi_zone_s = 0.7
    else: oi_zone_s = 0.3
    
    liq = m.get('liq_share_pct', 0) or 0
    if liq <= 0.20: liq_s = 1.0
    elif liq <= 0.30: liq_s = 0.7
    else: liq_s = 0.3
    
    oi_score = (oi_zone_s * 0.7) + (liq_s * 0.3)
    oi_score = max(0.0, min(1.0, oi_score))
    
    aqs = (geom_score * 0.50) + (flow_score * 0.30) + (oi_score * 0.20)
    return round(aqs, 3)

# --- 3. CLASSIFIER ---
def classify_main(m, flags, aqs):
    """
    –ü—Ä–∞–≤–∏–ª—å–Ω–∞—è –∫–ª–∞—Å—Å–∏—Ñ–∏–∫–∞—Ü–∏—è —Å —É—á–µ—Ç–æ–º —Ç–æ—Ä–≥–æ–≤–æ–π –ª–æ–≥–∏–∫–∏.
    –ü–ê–ù–ò–ö–ê (—Ä–∞–∑–≥—Ä—É–∑–∫–∞) > –ü–û–ì–õ–û–©–ï–ù–ò–ï > –æ—Å—Ç–∞–ª—å–Ω–æ–µ
    
    –ü–†–ê–í–ö–ò:
    1. ‚úÖ –í–µ—Ä–Ω—É–ª–∏ "–ü–†–û–ü–£–°–ö" –≤–º–µ—Å—Ç–æ "none"
    2. ‚úÖ –ü–æ–ø—Ä–∞–≤–∏–ª–∏ –ª–æ–≥–∏–∫—É –í—Å—Ç—Ä–µ—á–Ω–æ–≥–æ –Ω–∞–±–æ—Ä–∞ (–ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è)
    3. ‚úÖ –£–±—Ä–∞–ª–∏ —Ö–∞—Ä–¥–∫–æ–¥ 0.30, –∏—Å–ø–æ–ª—å–∑—É–µ–º m['liq_squeeze'] –∏ flags.get('liq_threshold')
    4. ‚úÖ –î–ª—è AQS < 0.50 –≤–æ–∑–≤—Ä–∞—â–∞–µ–º prob_final = 0 (–ø–æ–ª–Ω—ã–π –∏–≥–Ω–æ—Ä)
    5. ‚úÖ –í–æ–∑–≤—Ä–∞—â–∞–µ–º 4 –∑–Ω–∞—á–µ–Ω–∏—è –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏ (–±–µ–∑ prob_mod_composite)
    
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç: (cls, prob_final, summary, direction)
    """
    
    # ========================================================================
    # 0. GATES (KB 4.6)
    # ========================================================================
    # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ñ–ª–∞–≥ –∏–∑ app.py, —Ç–∞–∫ –∫–∞–∫ —Ç–∞–º —É–∂–µ —É—á—Ç–µ–Ω –≥–ª–æ–±–∞–ª—å–Ω—ã–π –ª–∏–º–∏—Ç
    liq = m.get('liq_share_pct', 0) or 0
    # –ü—ã—Ç–∞–µ–º—Å—è –ø–æ–ª—É—á–∏—Ç—å –ø–æ—Ä–æ–≥ –¥–ª—è –∫—Ä–∞—Å–∏–≤–æ–≥–æ –≤—ã–≤–æ–¥–∞, –µ—Å–ª–∏ –µ–≥–æ –Ω–µ—Ç - –¥–µ—Ñ–æ–ª—Ç 0.30
    liq_threshold = flags.get('liq_threshold', 0.30)
    
    if m.get('liq_squeeze') or liq > liq_threshold:
        return "NO_LABEL", 0, f"–°–∫–≤–∏–∑ –ª–∏–∫–≤–∏–¥–∞—Ü–∏–π (LiqShare {liq:.2f}% > {liq_threshold:.2f}%). –ü—Ä–æ–ø—É—Å–∫.", "–ü–†–û–ü–£–°–ö"
        
    rng = m.get('range', 0) or 0
    if rng == 0:
        return "NO_LABEL", 0, "–î–∏–∞–ø–∞–∑–æ–Ω 0.", "–ü–†–û–ü–£–°–ö"
        
    price_sign = m.get('price_sign', 0)
    cvd_sign = m.get('cvd_sign', 0)
    
    # Gate 3: –ú–µ—Ä—Ç–≤–∞—è —Å–≤–µ—á–∞
    if abs(price_sign) < 0.01 and abs(cvd_sign) < 0.01:
        return "NO_LABEL", 0, "–¶–µ–Ω–∞ –∏ CVD –Ω–µ –¥–≤–∏–∂—É—Ç—Å—è. –ú—ë—Ä—Ç–≤–∞—è —Å–≤–µ—á–∞.", "–ü–†–û–ü–£–°–ö"
    
    # ========================================================================
    # 1. Divergence Check (KB 4.1)
    # ========================================================================
    dpx = m.get('dpx', 0)
    pvd = m.get('price_vs_delta', 'neutral')
    
    valid_diver = ["mismatch", "div"]
    valid_match = ["match"]
    
    # Basic Divergence flag (Restored for debug/legacy compatibility)
    flag_diver = (dpx == -1) or (pvd in valid_diver)
    
    conflict_comment = ""
    prob_mod = 0
    prob_mod_composite = 0
    
    if dpx == 1 and pvd in valid_match:
        return "NO_LABEL", 0, "–ù–µ—Ç –¥–∏–≤–µ—Ä–≥–µ–Ω—Ü–∏–∏.", "–ü–†–û–ü–£–°–ö"
    elif (dpx == 1 and pvd in valid_diver) or (dpx == -1 and pvd in valid_match):
        prob_mod = -15
        conflict_comment = " (–ö–æ–Ω—Ñ–ª–∏–∫—Ç —Å–∏–≥–Ω–∞–ª–æ–≤)"
        
    # CVD Noise Check
    if flags['is_cvd_noise']:
        return "NO_LABEL", 0, "CVD —à—É–º", "–ü–†–û–ü–£–°–ö"
    
    # ========================================================================
    # 2. Main Classification (KB 4.7 + –¢–û–†–ì–û–í–ê–Ø –õ–û–ì–ò–ö–ê)
    # ========================================================================
    cls = "–ù–ï–í–û–ó–ú–û–ñ–ù–û_–ö–õ–ê–°–°–ò–§–ò–¶–ò–†–û–í–ê–¢–¨"
    prob_base = 0
    summary = ""
    direction = "–ü–†–û–ü–£–°–ö"
    
    doi = m.get('doi_pct', 0) or 0
    
    # ========================================================================
    # --- SCENARIO 1: AT_EDGE (–¶–ï–ù–ê –£ –£–†–û–í–ù–Ø) ---
    # ========================================================================
    if flags['at_edge']:
        
        # ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
        # TIER 1: –†–ê–ó–ì–†–£–ó–ö–ê (–ü–ê–ù–ò–ö–ê) ‚Üê –ì–õ–ê–í–ù–´–ô –î–û–ú–ò–ù–ò–†–£–Æ–©–ò–ô –°–ò–ì–ù–ê–õ!
        # ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
        if doi <= flags['t_unload']:
            cls = "–†–ê–ó–ì–†–£–ó–ö–ê_–ü–û–ó–ò–¶–ò–ô"
            ratio = abs(doi) / abs(flags['t_unload']) if flags['t_unload'] != 0 else 1
            prob_base = min(ratio * 80, 95)
            direction = "EXIT (–ª–∏–∫–≤–∏–¥–∞—Ü–∏—è –Ω–∞ —É—Ä–æ–≤–Ω–µ)"
            summary = f"‚ö†Ô∏è –ö–†–ò–¢–ò–ß–ï–°–ö–ò–ô: –û–ò —É–ø–∞–ª ({doi:.2f}%). –ú–∞—Å—Å–æ–≤–æ–µ –∑–∞–∫—Ä—ã—Ç–∏–µ (Unload), —Ä–∏—Å–∫ —Ä–∞–∑–≤–æ—Ä–æ—Ç–∞!"
        
        # ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
        # TIER 2: –ü–û–ì–õ–û–©–ï–ù–ò–ï (–∫–æ–Ω—Ç—Ä–æ–ª–∏—Ä—É–µ–º–æ–µ)
        # ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
        elif abs(doi) <= flags['a_tol']:
            if aqs >= 0.70:
                cls = "–°–ï–†–¢–ò–§–ò–¶–ò–†–û–í–ê–ù–ù–û–ï_–ü–û–ì–õ–û–©–ï–ù–ò–ï"
                prob_base = aqs * 100
                direction = "–õ–û–ù–ì" if price_sign == 1 else "–®–û–†–¢"
                summary = "–ê–∫—Ç–∏–≤–Ω—ã–π –ª–∏–º–∏—Ç–Ω—ã–π –∏–≥—Ä–æ–∫ –¥–µ—Ä–∂–∏—Ç —É—Ä–æ–≤–µ–Ω—å."
            elif aqs >= 0.50:
                cls = "–†–ê–°–•–û–ñ–î–ï–ù–ò–ï_–ë–ï–ó_–ö–õ–ê–°–°–ê"
                prob_base = aqs * 100
                direction = "–ú–û–ù–ò–¢–û–†"
                summary = "–ï—Å—Ç—å —Ä–∞—Å—Ö–æ–∂–¥–µ–Ω–∏–µ, –Ω–æ AQS < 0.70"
            else:
                # –ï—Å–ª–∏ AQS < 0.50, –ø–æ–ª–Ω—ã–π –∏–≥–Ω–æ—Ä (prob_final = 0)
                cls = "NO_LABEL"
                prob_base = 0
                direction = "–ü–†–û–ü–£–°–ö"
                summary = "AQS < 0.50, —à—É–º"
        
        # ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
        # TIER 3: –î–ò–í–ï–† –ù–ê –ö–†–û–ú–ö–ï
        # ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
        elif abs(doi) <= flags['sens']:
            cls = "–î–ò–í–ï–†_–ù–ê_–ö–†–û–ú–ö–ï"
            prob_base = min(aqs * 100, 60)
            direction = "–û–°–¢–û–†–û–ñ–ù–û"
            summary = "–û–ò –Ω–∞ –≥—Ä–∞–Ω–∏—Ü–µ –ø–æ—Ä–æ–≥–æ–≤–æ–π –∑–æ–Ω—ã."
        
        # ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
        # TIER 4: –í–°–¢–†–ï–ß–ù–´–ô –ù–ê–ë–û–† (—Ä–∞–Ω–Ω–∏–π)
        # ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
        elif abs(doi) <= flags['t_counter']:
            cls = "–í–°–¢–†–ï–ß–ù–´–ô_–ù–ê–ë–û–†"
            prob_base = min(aqs * 80, 85)
            direction = "–õ–û–ù–ì (—Ä–∞–Ω–Ω–∏–π)" if price_sign == 1 else "–®–û–†–¢ (—Ä–∞–Ω–Ω–∏–π)"
            summary = "–í—Å—Ç—Ä–µ—á–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è —Ñ–æ—Ä–º–∏—Ä—É–µ—Ç—Å—è."
        
        # ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
        # TIER 5: –û–ß–ï–ù–¨ –í–´–°–û–ö–ò–ô –û–ò
        # ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
        else:
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º: –û–ò —Ä–∞—Å—Ç–µ—Ç –≤ —Å—Ç–æ—Ä–æ–Ω—É —Ü–µ–Ω—ã (—Ç—Ä–µ–Ω–¥) –∏–ª–∏ –ø—Ä–æ—Ç–∏–≤ (–≤—Å—Ç—Ä–µ—á–Ω—ã–π)?
            
            if (price_sign == 1 and doi > 0) or (price_sign == -1 and doi < 0):
                # –û–ò —Ä–∞—Å—Ç–µ—Ç –ü–û –¢–†–ï–ù–î–£ (—Ç—Ä–µ–Ω–¥ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–∞–µ—Ç—Å—è)
                cls = "–ü–û–î–¢–í–ï–†–ñ–î–ï–ù–ò–ï_–¢–†–ï–ù–î–ê"
                prob_base = min(aqs * 85, 90)
                direction = "–õ–û–ù–ì (—Å–∏–ª—å–Ω—ã–π)" if price_sign == 1 else "–®–û–†–¢ (—Å–∏–ª—å–Ω—ã–π)"
                summary = "–°–∏–ª—å–Ω—ã–π –∏–º–ø—É–ª—å—Å: –û–ò —Ä–∞—Å—Ç–µ—Ç –ø–æ —Ç—Ä–µ–Ω–¥—É. –ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è."
            else:
                # –û–ò —Ä–∞—Å—Ç–µ—Ç –ü–†–û–¢–ò–í –¢–†–ï–ù–î–ê (–≤—Å—Ç—Ä–µ—á–Ω—ã–π –Ω–∞–±–æ—Ä –∏–ª–∏ –¥–∏–≤–µ—Ä)
                cls = "–í–°–¢–†–ï–ß–ù–´–ô_–ù–ê–ë–û–†"
                prob_base = aqs * 70
                direction = "–†–ò–°–ö"
                summary = "–°–∏–ª—å–Ω—ã–π –û–ò –ø—Ä–æ—Ç–∏–≤ —Ç—Ä–µ–Ω–¥–∞. –í—Å—Ç—Ä–µ—á–Ω—ã–π –Ω–∞–±–æ—Ä –∏–ª–∏ –∫–æ–Ω—Ç—Ä—Ç—Ä–µ–Ω–¥."
    
    # ========================================================================
    # --- SCENARIO 2: AIR (–¶–ï–ù–ê –í –í–û–ó–î–£–•–ï) ---
    # ========================================================================
    else:  # at_edge == False
        
        # ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
        # TIER 1: –†–ê–ó–ì–†–£–ó–ö–ê (–≤ –≤–æ–∑–¥—É—Ö–µ, –ë–ï–ó —É—Ä–æ–≤–Ω—è)
        # ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
        if doi <= flags['t_unload']:
            cls = "–†–ê–ó–ì–†–£–ó–ö–ê_–ü–û–ó–ò–¶–ò–ô"
            ratio = abs(doi) / abs(flags['t_unload']) if flags['t_unload'] != 0 else 1
            prob_base = min(ratio * 60, 90)
            direction = "EXIT"
            summary = "–ê–∫—Ç–∏–≤–Ω–æ–µ –∑–∞–∫—Ä—ã—Ç–∏–µ –ø–æ–∑–∏—Ü–∏–π –≤ –≤–æ–∑–¥—É—Ö–µ."
        
        # ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
        # TIER 2: –†–ê–°–•–û–ñ–î–ï–ù–ò–ï
        # ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
        elif abs(doi) <= flags['sens']:
            cls = "–†–ê–°–•–û–ñ–î–ï–ù–ò–ï_–ë–ï–ó_–ö–õ–ê–°–°–ê"
            prob_base = aqs * 100
            direction = "–ú–û–ù–ò–¢–û–†"
            summary = "–û–ò —Å–ª–∞–±–æ –¥–≤–∏–∂–µ—Ç—Å—è. –ñ–¥—ë–º —Ä–∞–∑–≤–∏—Ç–∏—è."
        
        # ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
        # TIER 3: –í–°–¢–†–ï–ß–ù–´–ô –ù–ê–ë–û–† (—Ä–∞–Ω–Ω–∏–π, –≤ –≤–æ–∑–¥—É—Ö–µ)
        # ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
        elif abs(doi) <= flags['t_counter']:
            cls = "–í–°–¢–†–ï–ß–ù–´–ô_–ù–ê–ë–û–†"
            prob_base = min(aqs * 75, 75)
            direction = "–õ–û–ù–ì (—Ä–∞–Ω–Ω–∏–π)" if price_sign == 1 else "–®–û–†–¢ (—Ä–∞–Ω–Ω–∏–π)"
            summary = "–ù–∞–±–æ—Ä –ø–æ–∑–∏—Ü–∏–π –≤ –≤–æ–∑–¥—É—Ö–µ (—Ä–∞–Ω–Ω–∏–π)."
        
        # ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
        # TIER 4: –û–ß–ï–ù–¨ –í–´–°–û–ö–ò–ô –û–ò –í –í–û–ó–î–£–•–ï
        # ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
        else:
            if (price_sign == 1 and doi > 0) or (price_sign == -1 and doi < 0):
                # –û–ò —Ä–∞—Å—Ç–µ—Ç –ü–û –¢–†–ï–ù–î–£ (–≤ –≤–æ–∑–¥—É—Ö–µ —Ç—Ä–µ–Ω–¥ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–∞–µ—Ç—Å—è)
                cls = "–ü–û–î–¢–í–ï–†–ñ–î–ï–ù–ò–ï_–¢–†–ï–ù–î–ê"
                prob_base = min(aqs * 80, 85)
                direction = "–õ–û–ù–ì (—Å–∏–ª—å–Ω—ã–π)" if price_sign == 1 else "–®–û–†–¢ (—Å–∏–ª—å–Ω—ã–π)"
                summary = "–°–∏–ª—å–Ω—ã–π –∏–º–ø—É–ª—å—Å –≤ –≤–æ–∑–¥—É—Ö–µ: –û–ò —Ä–∞—Å—Ç–µ—Ç –ø–æ —Ç—Ä–µ–Ω–¥—É."
            else:
                # –û–ò —Ä–∞—Å—Ç–µ—Ç –ü–†–û–¢–ò–í –¢–†–ï–ù–î–ê (–≤—Å—Ç—Ä–µ—á–Ω—ã–π –Ω–∞–±–æ—Ä)
                cls = "–í–°–¢–†–ï–ß–ù–´–ô_–ù–ê–ë–û–†"
                prob_base = min(aqs * 65, 75)
                direction = "–†–ò–°–ö"
                summary = "–í—Å—Ç—Ä–µ—á–Ω—ã–π –û–ò –≤ –≤–æ–∑–¥—É—Ö–µ (–≤—ã—Å–æ–∫–∏–π)."
    
    # --- 2.5 COMPOSITE LOGIC (HYBRID APPROACH) ---
    prob_mod_composite = 0
    composite_comment = ""
    
    comp_text = m.get('x_ray_composite') or m.get('composite_summary')
    if comp_text:
        comp_cvd = extract_numeric_value(comp_text, "–ö–æ–º–ø–æ–∑–∏—Ç")
        
        if comp_cvd is not None:
            cvd_pct = m.get('cvd_pct', 0)
            
            divergence_value = cvd_pct - comp_cvd
            divergence_magnitude = (
                abs(divergence_value) / max(abs(cvd_pct), abs(comp_cvd))
                if max(abs(cvd_pct), abs(comp_cvd)) > 0
                else 0
            )
            
            signs_match = (sign(cvd_pct) == sign(comp_cvd))
            is_significant_main = abs(cvd_pct) > 1.5
            is_significant_comp = abs(comp_cvd) > 1.5
            
            # === HYBRID CASE A ===
            if not signs_match and is_significant_main and is_significant_comp:
                
                if divergence_magnitude > 0.50:
                    # –≠–ö–°–¢–†–ï–ú–ê–õ–¨–ù–´–ô –∫–æ–Ω—Ñ–ª–∏–∫—Ç ‚Üí –£–ë–ò–ô–°–¢–í–û
                    prob_mod_composite = -100
                    cls = "NO_LABEL"
                    return cls, 0, f"{summary} üö® –≠–ö–°–¢–†–ï–ú–ê–õ–¨–ù–´–ô –ö–û–ù–§–õ–ò–ö–¢ –ö–û–ú–ü–û–ó–ò–¢–ê - –ê–ù–ê–õ–ò–ó –û–¢–ú–ï–ù–Ø–ï–¢–°–Ø", "–ü–†–û–ü–£–°–ö"
                else:
                    # –û–±—ã—á–Ω—ã–π –∫–æ–Ω—Ñ–ª–∏–∫—Ç ‚Üí –®–¢–†–ê–§
                    prob_mod_composite = -50
                    composite_comment = (
                        f"‚ö†Ô∏è –ö–û–ù–§–õ–ò–ö–¢ –ö–û–ú–ü–û–ó–ò–¢–ê: –∑–Ω–∞–∫–∏ –ø—Ä–æ—Ç–∏–≤–æ–ø–æ–ª–æ–∂–Ω—ã "
                        f"(Binance {cvd_pct:+.2f}% vs –ö–æ–º–ø–æ–∑–∏—Ç {comp_cvd:+.2f}%, —Ä–∞–∑–Ω–∏—Ü–∞ {divergence_magnitude:.0%}). ‚àí50%"
                    )
            
            # === CASE B ===
            elif signs_match:
                if divergence_magnitude < 0.05:
                    prob_mod_composite = 0
                    composite_comment = "‚úÖ –ö–æ–º–ø–æ–∑–∏—Ç —Å–æ–≥–ª–∞—Å–æ–≤–∞–Ω: —Ä–∞—Å—Ö–æ–∂–¥–µ–Ω–∏–µ < 5%."
                else:
                    bonus = divergence_magnitude * 20
                    bonus = min(bonus, 25)
                    prob_mod_composite = bonus
                    composite_comment = (
                        f"‚úÖ –ö–æ–º–ø–æ–∑–∏—Ç –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–∞–µ—Ç: –≤—Å–µ –±–∏—Ä–∂–∏ —Å–æ–≥–ª–∞—Å–æ–≤–∞–Ω—ã. +{bonus:.0f}%"
                    )
            
            # === CASE C ===
            else:
                penalty = divergence_magnitude * 15
                penalty = min(penalty, 30)
                prob_mod_composite = -penalty
                composite_comment = (
                    f"‚ö†Ô∏è –°–ª–∞–±–æ–µ —Ä–∞—Å—Ö–æ–∂–¥–µ–Ω–∏–µ –º–µ–∂–¥—É –±–∏—Ä–∂–∞–º–∏: -{penalty:.0f}%"
                )
                
    # --- 3. FINAL PROBABILITY CORRECTION ---
    # ========================================================================
    # 3. –§–ò–ù–ê–õ–¨–ù–ê–Ø –ö–û–†–†–ï–ö–¶–ò–Ø –í–ï–†–û–Ø–¢–ù–û–°–¢–ò
    # ========================================================================
    prob_final = prob_base + prob_mod
    
    if conflict_comment:
        summary += conflict_comment
    
    # --- UPDATED TILT PENALTY (AI Audit #8) ---
    tilt = m.get('tilt_pct', 0) or 0
    cvd_pct = m.get('cvd_pct', 0) or 0
    
    tilt_sign = sign(tilt)
    cvd_sign_val = sign(cvd_pct)
    
    # Conflict: Tilt and CVD point in opposite directions?
    if tilt_sign * cvd_sign_val < 0:
        if abs(tilt) >= 15:
            pen = 20
            sev = "–°–ò–õ–¨–ù–´–ô –∫–æ–Ω—Ñ–ª–∏–∫—Ç"
        elif abs(tilt) >= 10:
            pen = 15
            sev = "–ö–æ–Ω—Ñ–ª–∏–∫—Ç"
        elif abs(tilt) >= 5:
            pen = 10
            sev = "–°–ª–∞–±—ã–π –∫–æ–Ω—Ñ–ª–∏–∫—Ç"
        else:
            pen = 0
            
            if pen > 0:
                prob_final -= pen
                summary += f" ({sev} Tilt-CVD)"
    
    # --- 3.1 ADD COMPOSITE MODIFIERS ---
    
    prob_final += prob_mod_composite
    if composite_comment:
        summary += f" {composite_comment}"
    
    # --- STRICT FINAL GATES (AI Audit #7) ---
    # –î–ª—è NO_LABEL, –ù–ï–í–û–ó–ú–û–ñ–ù–û_–ö–õ–ê–°–°–ò–§–ò–¶–ò–†–û–í–ê–¢–¨ –∏–ª–∏ AQS < 0.50 ‚Üí prob_final = 0 (–ø–æ–ª–Ω—ã–π –∏–≥–Ω–æ—Ä)
    if cls == "NO_LABEL" or cls == "–ù–ï–í–û–ó–ú–û–ñ–ù–û_–ö–õ–ê–°–°–ò–§–ò–¶–ò–†–û–í–ê–¢–¨":
        prob_final = 0
    elif aqs < 0.50:
         # Strict AQS noise filter
        prob_final = 0  # FIX: Typos fixed (prop -> prob)
        cls = "NO_LABEL"
        summary = "AQS < 0.50 (–®—É–º). –°–∏–≥–Ω–∞–ª –æ—Ç–±—Ä–æ—à–µ–Ω."
        direction = "–ü–†–û–ü–£–°–ö"
    else:
        # –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç–∏ (—Ç–æ–ª—å–∫–æ –¥–ª—è –≤–∞–ª–∏–¥–Ω—ã—Ö –∫–ª–∞—Å—Å–æ–≤)
        prob_final = max(min(prob_final, 99), 15)  # Min 15% –¥–ª—è –≤–∞–ª–∏–¥–Ω–æ–≥–æ —Å–∏–≥–Ω–∞–ª–∞
    
    return cls, round(prob_final), summary, direction


# --- HELPER FUNCTIONS FOR REPORT (AI Audit #1, #2, #5) ---

def get_cvd_description(m, flags):
    """Generates detailed CVD description"""
    cvd_pct = m.get('cvd_pct', 0) or 0
    is_cvd_noise = flags.get('is_cvd_noise', False)
    
    # –®–ê–ì 1: –ï—Å–ª–∏ —à—É–º ‚Üí –ø—Ä–æ—Å—Ç–æ "–®—É–º"
    if is_cvd_noise:
        return "–®—É–º"  # –ë–ï–ó –ù–ê–ü–†–ê–í–õ–ï–ù–ò–Ø!
    
    # –®–ê–ì 2: –ü–æ—Ä–æ–≥–∏
    ACTIVE_THRESHOLD = 0.50
    STRONG_THRESHOLD = 1.00
    VERY_STRONG_THRESHOLD = 2.00
    
    # FIX: Professional descriptions (AI Audit Suggestion)
    if cvd_pct > ACTIVE_THRESHOLD:
        if cvd_pct > VERY_STRONG_THRESHOLD: return "–ü–æ–∫—É–ø–∞—Ç–µ–ª–∏ (–û—á–µ–Ω—å —Å–∏–ª—å–Ω—ã–µ)"
        elif cvd_pct > STRONG_THRESHOLD: return "–ü–æ–∫—É–ø–∞—Ç–µ–ª–∏ (–°–∏–ª—å–Ω—ã–µ)"
        else: return "–ü–æ–∫—É–ø–∞—Ç–µ–ª–∏"
    elif cvd_pct < -ACTIVE_THRESHOLD:
        if cvd_pct < -VERY_STRONG_THRESHOLD: return "–ü—Ä–æ–¥–∞–≤—Ü—ã (–û—á–µ–Ω—å —Å–∏–ª—å–Ω—ã–µ)"
        elif cvd_pct < -STRONG_THRESHOLD: return "–ü—Ä–æ–¥–∞–≤—Ü—ã (–°–∏–ª—å–Ω—ã–µ)"
        else: return "–ü—Ä–æ–¥–∞–≤—Ü—ã"
    else:
        return "–ù–µ–π—Ç—Ä–∞–ª—å–Ω—ã–π"

def get_doi_description(m, flags):
    """Generates detailed DOI description with thresholds"""
    doi_pct = m.get('doi_pct', 0) or 0
    # Use existing thresholds from flags
    threshold = flags['a_tol'] if flags['at_edge'] else flags['sens']
    
    if abs(doi_pct) < threshold:
        return "–°—Ç–∞–±–∏–ª—å–Ω—ã–π (–≤ –Ω–æ—Ä–º–µ)"
    elif abs(doi_pct) < threshold * 2:
        return "–†–æ—Å—Ç –û–ò (—É–º–µ—Ä–µ–Ω–Ω—ã–π)" if doi_pct > 0 else "–ü–∞–¥–µ–Ω–∏–µ –û–ò (—É–º–µ—Ä–µ–Ω–Ω–æ–µ)"
    else:
        return "–†–æ—Å—Ç –û–ò (—Å–∏–ª—å–Ω—ã–π!)" if doi_pct > 0 else "–ü–∞–¥–µ–Ω–∏–µ –û–ò (—Å–∏–ª—å–Ω–æ–µ!)"

def get_quality_description(prob_final, trade_status):
    """Generates quality description based on status"""
    quality_map = {
        "–ü–†–û–ü–£–°–ö": "–ù–µ—Ç —Å–∏–≥–Ω–∞–ª–∞",
        "–°–õ–ê–ë–´–ô_–°–ò–ì–ù–ê–õ": "–°–ª–∞–±–∞—è",
        "–ù–ï–ô–¢–†–ê–õ–¨–ù–´–ô": "–°—Ä–µ–¥–Ω—è—è",
        "–°–ò–õ–¨–ù–´–ô_–°–ò–ì–ù–ê–õ": "–í—ã—Å–æ–∫–∞—è",
        "–û–ß–ï–ù–¨_–°–ò–õ–¨–ù–´–ô": "–û—á–µ–Ω—å –≤—ã—Å–æ–∫–∞—è",
        "–ö–†–ò–¢–ò–ß–ï–°–ö–ò–ô": "–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è (–ú–ê–ö–°–ò–ú–£–ú!)"
    }
    return quality_map.get(trade_status, "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ")

# --- UPDATED TRADE STATUS (AI Audit #4) ---
def get_trade_status(prob_final, cls):
    """
    –û–ø—Ä–µ–¥–µ–ª—è–µ—Ç —Å—Ç–∞—Ç—É—Å —Å–¥–µ–ª–∫–∏ –Ω–∞ –æ—Å–Ω–æ–≤–µ –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç–∏ –∏ –∫–ª–∞—Å—Å–∞.
    –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç: –°–ø–µ—Ü –∫–ª–∞—Å—Å—ã -> –í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å
    """
    if prob_final == 0 or cls == "NO_LABEL" or cls == "–ù–ï–í–û–ó–ú–û–ñ–ù–û_–ö–õ–ê–°–°–ò–§–ò–¶–ò–†–û–í–ê–¢–¨":
        return "–ü–†–û–ü–£–°–ö"
    
    # –°–ü–ï–¶ –ö–õ–ê–°–°–´ (–ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç)
    if cls == "–†–ê–ó–ì–†–£–ó–ö–ê_–ü–û–ó–ò–¶–ò–ô":
        return "–ö–†–ò–¢–ò–ß–ï–°–ö–ò–ô"  # –í–°–ï–ì–î–ê!
    
    if cls == "–ü–û–î–¢–í–ï–†–ñ–î–ï–ù–ò–ï_–¢–†–ï–ù–î–ê":
        return "–û–ß–ï–ù–¨_–°–ò–õ–¨–ù–´–ô" if prob_final >= 85 else "–°–ò–õ–¨–ù–´–ô_–°–ò–ì–ù–ê–õ"
    
    if cls == "–°–ï–†–¢–ò–§–ò–¶–ò–†–û–í–ê–ù–ù–û–ï_–ü–û–ì–õ–û–©–ï–ù–ò–ï":
        if prob_final >= 85: return "–û–ß–ï–ù–¨_–°–ò–õ–¨–ù–´–ô"
        elif prob_final >= 70: return "–°–ò–õ–¨–ù–´–ô_–°–ò–ì–ù–ê–õ"
        else: return "–ù–ï–ô–¢–†–ê–õ–¨–ù–´–ô"
    
    if cls == "–í–°–¢–†–ï–ß–ù–´–ô_–ù–ê–ë–û–†":
        return "–°–ò–õ–¨–ù–´–ô_–°–ò–ì–ù–ê–õ" if prob_final >= 65 else "–ù–ï–ô–¢–†–ê–õ–¨–ù–´–ô"
    
    if cls in ["–†–ê–°–•–û–ñ–î–ï–ù–ò–ï_–ë–ï–ó_–ö–õ–ê–°–°–ê", "–î–ò–í–ï–†_–ù–ê_–ö–†–û–ú–ö–ï"]:
        return "–°–ò–õ–¨–ù–´–ô_–°–ò–ì–ù–ê–õ" if prob_final >= 70 else "–ù–ï–ô–¢–†–ê–õ–¨–ù–´–ô"
    
    # –ü–û –í–ï–†–û–Ø–¢–ù–û–°–¢–ò (–æ—Å—Ç–∞–ª—å–Ω—ã–µ)
    if prob_final >= 95: return "–ö–†–ò–¢–ò–ß–ï–°–ö–ò–ô"
    elif prob_final >= 85: return "–û–ß–ï–ù–¨_–°–ò–õ–¨–ù–´–ô"
    elif prob_final >= 70: return "–°–ò–õ–¨–ù–´–ô_–°–ò–ì–ù–ê–õ"
    elif prob_final >= 50: return "–ù–ï–ô–¢–†–ê–õ–¨–ù–´–ô"
    elif prob_final >= 30: return "–°–õ–ê–ë–´–ô_–°–ò–ì–ù–ê–õ"
    else: return "–ü–†–û–ü–£–°–ö"

# --- 4. GENERATE REPORT (Updated v3.2) ---

def get_class_description(cls):
    """
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø–æ–ª–Ω—É—é —Ç—Ä–∞–∫—Ç–æ–≤–∫—É –∫–ª–∞—Å—Å–∞.
    """
    CLASS_DESCRIPTIONS = {
        "NO_LABEL": {
            "–∫—Ä–∞—Ç–∫–æ–µ": "–ù–µ –∫–ª–∞—Å—Å–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω–æ",
            "–ø–æ–ª–Ω–æ–µ": "–ù–µ –∫–ª–∞—Å—Å–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω–æ (—à—É–º, –≥–µ–π—Ç, –∏–ª–∏ –Ω–µ—Ç –¥–∏–≤–µ—Ä–≥–µ–Ω—Ü–∏–∏)",
            "—Ç—Ä–∞–∫—Ç–æ–≤–∫–∞": "–°–∏–≥–Ω–∞–ª–∞ –Ω–µ—Ç. –°–≤–µ—á–∞ –ª–∏–±–æ –ø—Ä–æ—à–ª–∞ –≥–µ–π—Ç—ã (high liq, high range), –ª–∏–±–æ CVD —à—É–º, –ª–∏–±–æ –Ω–µ—Ç –¥–∏–≤–µ—Ä–≥–µ–Ω—Ü–∏–∏ —Ü–µ–Ω–∞-–æ–±—ä–µ–º.",
            "–¥–µ–π—Å—Ç–≤–∏–µ": "–ü–†–û–ü–£–°–ö - –Ω–µ —Ç—Ä–µ–π–¥–∏—Ç—å",
            "emoji": "‚ö™"
        },
        
        "–°–ï–†–¢–ò–§–ò–¶–ò–†–û–í–ê–ù–ù–û–ï_–ü–û–ì–õ–û–©–ï–ù–ò–ï": {
            "–∫—Ä–∞—Ç–∫–æ–µ": "–°–µ—Ä—Ç–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –ø–æ–≥–ª–æ—â–µ–Ω–∏–µ",
            "–ø–æ–ª–Ω–æ–µ": "–í—ã—Å–æ–∫–∞—è —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å –≤ –ø–æ–≥–ª–æ—â–µ–Ω–∏–∏ (AQS >= 0.70, —É —É—Ä–æ–≤–Ω—è)",
            "—Ç—Ä–∞–∫—Ç–æ–≤–∫–∞": "–ê–∫—Ç–∏–≤–Ω—ã–π –ª–∏–º–∏—Ç–Ω—ã–π –∏–≥—Ä–æ–∫ –¥–µ—Ä–∂–∏—Ç —É—Ä–æ–≤–µ–Ω—å. –ì–µ–æ–º–µ—Ç—Ä–∏—è, –æ–±—ä—ë–º –∏ –ø–æ—Ç–æ–∫ CVD –∏–¥–µ–∞–ª—å–Ω–æ —Å–æ–≥–ª–∞—Å–æ–≤–∞–Ω—ã. –≠—Ç–æ –∫–æ–Ω—Ç—Ä–æ–ª–∏—Ä—É–µ–º–æ–µ –ø–æ–≥–ª–æ—â–µ–Ω–∏–µ –Ω–∞ –≥—Ä–∞–Ω–∏—Ü–µ - –≤—ã—Å–æ–∫–∏–π –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª —Ä–∞–∑–≤–æ—Ä–æ—Ç–∞ –∏–ª–∏ —É–¥–µ—Ä–∂–∞–Ω–∏—è —É—Ä–æ–≤–Ω—è. –°–∏–≥–Ω–∞–ª –æ—á–µ–Ω—å —á–∏—Å—Ç—ã–π.",
            "–¥–µ–π—Å—Ç–≤–∏–µ": "–¢–†–ï–ô–î–ò–¢–¨ –∞–∫—Ç–∏–≤–Ω–æ - –æ–¥–∏–Ω –∏–∑ –ª—É—á—à–∏—Ö —Å–∏–≥–Ω–∞–ª–æ–≤",
            "emoji": "‚úÖ"
        },
        
        "–†–ê–°–•–û–ñ–î–ï–ù–ò–ï_–ë–ï–ó_–ö–õ–ê–°–°–ê": {
            "–∫—Ä–∞—Ç–∫–æ–µ": "–†–∞—Å—Ö–æ–∂–¥–µ–Ω–∏–µ (–Ω–µ—è—Å–Ω–æ–µ)",
            "–ø–æ–ª–Ω–æ–µ": "–î–∏–≤–µ—Ä–≥–µ–Ω—Ü–∏—è –µ—Å—Ç—å, –Ω–æ –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —É–±–µ–¥–∏—Ç–µ–ª—å–Ω–∞",
            "—Ç—Ä–∞–∫—Ç–æ–≤–∫–∞": "–¶–µ–Ω–∞ –∏ CVD –¥–≤–∏–∂—É—Ç—Å—è –≤ —Ä–∞–∑–Ω—ã–µ —Å—Ç–æ—Ä–æ–Ω—ã, –Ω–æ AQS < 0.70 –∏–ª–∏ –∫–∞—á–µ—Å—Ç–≤–æ –ø–æ—Ç–æ–∫–∞ –Ω–∏–∑–∫–æ. –î–∏–≤–µ—Ä–≥–µ–Ω—Ü–∏—è –µ—Å—Ç—å, –Ω–æ —ç—Ç–æ –º–æ–∂–µ—Ç –±—ã—Ç—å –∫–∞–∫ —Ä–∞–∑–≤–æ—Ä–æ—Ç, —Ç–∞–∫ –∏ –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏–µ. –ù—É–∂–Ω–æ –∂–¥–∞—Ç—å –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –Ω–∞ —Å–ª–µ–¥—É—é—â–µ–π —Å–≤–µ—á–µ.",
            "–¥–µ–π—Å—Ç–≤–∏–µ": "–ú–û–ù–ò–¢–û–†–ò–¢–¨ - –ø–æ–¥–æ–∂–¥–∞—Ç—å –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è, –Ω–µ –≤—Ö–æ–¥–∏—Ç—å –Ω–∞ —ç—Ç–æ–π",
            "emoji": "‚ùì"
        },
        
        "–î–ò–í–ï–†_–ù–ê_–ö–†–û–ú–ö–ï": {
            "–∫—Ä–∞—Ç–∫–æ–µ": "–î–∏–≤–µ—Ä–≥–µ–Ω—Ü–∏—è –Ω–∞ –∫—Ä–æ–º–∫–µ",
            "–ø–æ–ª–Ω–æ–µ": "–î–∏–≤–µ—Ä–≥–µ–Ω—Ü–∏—è –Ω–∞ –≥—Ä–∞–Ω–∏—Ü–µ –ø–æ—Ä–æ–≥–æ–≤–æ–π –∑–æ–Ω—ã",
            "—Ç—Ä–∞–∫—Ç–æ–≤–∫–∞": "–¶–µ–Ω–∞ —É —É—Ä–æ–≤–Ω—è (–ø–æ–¥–¥–µ—Ä–∂–∫–∏/—Å–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏—è), CVD –¥–≤–∏–∂–µ—Ç—Å—è –≤ –¥—Ä—É–≥—É—é —Å—Ç–æ—Ä–æ–Ω—É, –Ω–æ –û–ò –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ –∑–æ–Ω–µ —á—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ (SENS). –≠—Ç–æ –ø–µ—Ä–µ—Ö–æ–¥–Ω–∞—è —Ñ–∞–∑–∞ - —É—Ä–æ–≤–µ–Ω—å –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—Ä–æ–±–∏—Ç –∏–ª–∏ –∑–∞—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω. –ù—É–∂–Ω–æ –Ω–∞–±–ª—é–¥–µ–Ω–∏–µ, –Ω–æ —Å–∏–≥–Ω–∞–ª —Å–ª–∞–±—ã–π.",
            "–¥–µ–π—Å—Ç–≤–∏–µ": "–û–°–¢–û–†–û–ñ–ù–û - —Ç–æ–ª—å–∫–æ –ø—Ä–∏ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–∏ –Ω–∞ —Å–ª–µ–¥—É—é—â–µ–π —Å–≤–µ—á–µ",
            "emoji": "‚ö†Ô∏è"
        },
        
        "–í–°–¢–†–ï–ß–ù–´–ô_–ù–ê–ë–û–†": {
            "–∫—Ä–∞—Ç–∫–æ–µ": "–í—Å—Ç—Ä–µ—á–Ω—ã–π –Ω–∞–±–æ—Ä –ø–æ–∑–∏—Ü–∏–π",
            "–ø–æ–ª–Ω–æ–µ": "–ê–∫—Ç–∏–≤–Ω—ã–π –û–ò –ø—Ä–æ—Ç–∏–≤ —Ü–µ–Ω—ã (–Ω–∞–±–æ—Ä –ø–æ–∑–∏—Ü–∏–π)",
            "—Ç—Ä–∞–∫—Ç–æ–≤–∫–∞": "–¶–µ–Ω–∞ —Ä–∞—Å—Ç–µ—Ç (–∏–ª–∏ –ø–∞–¥–∞–µ—Ç), –Ω–æ –û–ò —Ä–∞—Å—Ç–µ—Ç –≤ –ø—Ä–æ—Ç–∏–≤–æ–ø–æ–ª–æ–∂–Ω—É—é —Å—Ç–æ—Ä–æ–Ω—É. –≠—Ç–æ –æ–∑–Ω–∞—á–∞–µ—Ç, —á—Ç–æ –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∏ —Ü–µ–Ω—ã –∞–∫—Ç–∏–≤–Ω–æ –æ—Ç–∫—Ä—ã–≤–∞—é—Ç –ø–æ–∑–∏—Ü–∏–∏. –õ–∏–±–æ —ç—Ç–æ –∫–æ–Ω—Ç—Ä—Ç—Ä–µ–Ω–¥, –ª–∏–±–æ –≤—Å—Ç—Ä–µ—á–Ω–∞—è –ª–æ–≤—É—à–∫–∞. –ü–æ—Ç–µ–Ω—Ü–∏–∞–ª —Ä–∞–∑–≤–æ—Ä–æ—Ç–∞ –∏–ª–∏ –ø—Ä–æ—Å—Ç–æ –≤—Å—Ç—Ä–µ—á–Ω—ã–π –Ω–∞–±–æ—Ä –¥–ª—è –¥–∞–ª—å–Ω–µ–π—à–µ–≥–æ —Ö–æ–¥–∞.",
            "–¥–µ–π—Å—Ç–≤–∏–µ": "–†–ò–°–ö - –º–æ–∂–µ—Ç –±—ã—Ç—å –ª–æ–≤—É—à–∫–∞ –∏–ª–∏ –≤—Å—Ç—Ä–µ—á–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è",
            "emoji": "‚öîÔ∏è"
        },
        
        "–†–ê–ó–ì–†–£–ó–ö–ê_–ü–û–ó–ò–¶–ò–ô": {
            "–∫—Ä–∞—Ç–∫–æ–µ": "–†–∞–∑–≥—Ä—É–∑–∫–∞ (–ø–∞–Ω–∏–∫–∞)",
            "–ø–æ–ª–Ω–æ–µ": "–í—ã—Ö–æ–¥ –∏–∑ –ø–æ–∑–∏—Ü–∏–π (–æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω–æ–µ –û–ò)",
            "—Ç—Ä–∞–∫—Ç–æ–≤–∫–∞": "–û–ò —Ä–µ–∑–∫–æ —É–ø–∞–ª –Ω–∏–∂–µ –ø–æ—Ä–æ–≥–∞ —Ä–∞–∑–≥—Ä—É–∑–∫–∏ (t_unload). –≠—Ç–æ –ü–ê–ù–ò–ö–ê - –º–∞—Å—Å–æ–≤–æ–µ –∑–∞–∫—Ä—ã—Ç–∏–µ –ø–æ–∑–∏—Ü–∏–π. –¶–µ–Ω–∞ –±—ã–ª–∞ —É —É—Ä–æ–≤–Ω—è –∏–ª–∏ –≤ –≤–æ–∑–¥—É—Ö–µ, –Ω–æ –∏–≥—Ä–æ–∫–∏ —Å—Ä–æ—á–Ω–æ –≤—ã—Ö–æ–¥—è—Ç. –≠—Ç–æ –æ–¥–∏–Ω –∏–∑ —Å–∞–º—ã—Ö –Ω–∞–¥–µ–∂–Ω—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤ (90-95% –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å). –ü–æ—Å–ª–µ —Ä–∞–∑–≥—Ä—É–∑–∫–∏ –æ–±—ã—á–Ω–æ –∏–¥–µ—Ç –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ –∏–ª–∏ –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏–µ –ø–∞–¥–µ–Ω–∏—è.",
            "–¥–µ–π—Å—Ç–≤–∏–µ": "–ö–†–ò–¢–ò–ß–ï–°–ö–ò–ô - –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –≤–Ω–∏–º–∞–Ω–∏–µ! –ù–µ–º–µ–¥–ª–µ–Ω–Ω–æ –∑–∞–∫—Ä—ã—Ç—å –ª–æ–Ω–≥ –∏–ª–∏ –≤–æ–π—Ç–∏ –≤ —à–æ—Ä—Ç",
            "emoji": "üö®"
        },
        
        "–ü–û–î–¢–í–ï–†–ñ–î–ï–ù–ò–ï_–¢–†–ï–ù–î–ê": {
            "–∫—Ä–∞—Ç–∫–æ–µ": "–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ —Ç—Ä–µ–Ω–¥–∞",
            "–ø–æ–ª–Ω–æ–µ": "–°–∏–ª—å–Ω—ã–π –∏–º–ø—É–ª—å—Å: –û–ò —Ä–∞—Å—Ç–µ—Ç –ø–æ —Ç—Ä–µ–Ω–¥—É",
            "—Ç—Ä–∞–∫—Ç–æ–≤–∫–∞": "–¶–µ–Ω–∞ —Ä–∞—Å—Ç–µ—Ç –ò –û–ò —Ä–∞—Å—Ç–µ—Ç –≤ —Ç—É –∂–µ —Å—Ç–æ—Ä–æ–Ω—É. –≠—Ç–æ –º–æ–Ω–æ–ª–∏—Ç–Ω–æ–µ –¥–≤–∏–∂–µ–Ω–∏–µ - –∏–≥—Ä–æ–∫–∏ –≤—Ö–æ–¥—è—Ç –ò —Ü–µ–Ω–∞ –∏–¥–µ—Ç –≤–≤–µ—Ä—Ö. –ü–æ–ª–Ω–∞—è —Å–æ–≥–ª–∞—Å–æ–≤–∞–Ω–Ω–æ—Å—Ç—å. –≠—Ç–æ –æ–¥–∏–Ω –∏–∑ —Å–∞–º—ã—Ö –ø—Ä–∏–±—ã–ª—å–Ω—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤ (85-95% –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å). –¢—Ä–µ–Ω–¥ –±—É–¥–µ—Ç –ø—Ä–æ–¥–æ–ª–∂–∞—Ç—å—Å—è.",
            "–¥–µ–π—Å—Ç–≤–∏–µ": "–û–ß–ï–ù–¨ –°–ò–õ–¨–ù–´–ô - –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π –≤—Ö–æ–¥, –¥–æ–±–∞–≤–ª—è—Ç—å –ø–æ —Ü–µ–Ω–µ",
            "emoji": "üìà"
        },
        
        "–ù–ï–í–û–ó–ú–û–ñ–ù–û_–ö–õ–ê–°–°–ò–§–ò–¶–ò–†–û–í–ê–¢–¨": {
            "–∫—Ä–∞—Ç–∫–æ–µ": "–ù–µ–≤–æ–∑–º–æ–∂–Ω–æ –∫–ª–∞—Å—Å–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞—Ç—å",
            "–ø–æ–ª–Ω–æ–µ": "–°–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ –ø—Ä–æ—Ç–∏–≤–æ—Ä–µ—á–∏–π –∏–ª–∏ —à—É–º–∞",
            "—Ç—Ä–∞–∫—Ç–æ–≤–∫–∞": "–°–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ –∫–æ–Ω—Ñ–ª–∏–∫—Ç—É—é—â–∏—Ö —Å–∏–≥–Ω–∞–ª–æ–≤. –ù–∞–ø—Ä–∏–º–µ—Ä: —Ü–µ–Ω–∞ –≤–≤–µ—Ä—Ö, CVD –≤–Ω–∏–∑, Tilt –∫–æ–Ω—Ñ–ª–∏–∫—Ç—É–µ—Ç —Å CVD, –û–ò –Ω–µ—Å—Ç–∞–±–∏–ª–µ–Ω. –≠—Ç–æ –ø–æ–ª–Ω—ã–π —Ö–∞–æ—Å - –∫–ª–∞—Å—Å–∏—Ñ–∏–∫–∞—Ü–∏—è –Ω–µ–≤–æ–∑–º–æ–∂–Ω–∞.",
            "–¥–µ–π—Å—Ç–≤–∏–µ": "–ü–†–û–ü–£–°–ö - –Ω–µ —Ç—Ä–µ–π–¥–∏—Ç—å, —Å–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ —à—É–º–∞",
            "emoji": "üå™Ô∏è"
        }
    }
    
    return CLASS_DESCRIPTIONS.get(cls, {
        "–∫—Ä–∞—Ç–∫–æ–µ": "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –∫–ª–∞—Å—Å",
        "–ø–æ–ª–Ω–æ–µ": "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –∫–ª–∞—Å—Å",
        "—Ç—Ä–∞–∫—Ç–æ–≤–∫–∞": "–ö–ª–∞—Å—Å –Ω–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω –≤ —Å–∏—Å—Ç–µ–º–µ",
        "–¥–µ–π—Å—Ç–≤–∏–µ": "–ü–†–û–ü–£–°–ö",
        "emoji": "‚ùì"
    })

def generate_diver_report(m, location_ui):
    """Generates report v3.2 —Å –¢–†–ê–ö–¢–û–í–ö–û–ô –∫–ª–∞—Å—Å–∞"""
    
    flags = prepare_logic_flags(m, location_ui)
    aqs = calculate_aqs(m, flags)
    cls, prob, summary, direction = classify_main(m, flags, aqs)
    
    trade_status = get_trade_status(prob, cls)
    
    # ‚úÖ –ù–û–í–û–ï: –ü–æ–ª—É—á–∏—Ç—å –ø–æ–ª–Ω—É—é —Ç—Ä–∞–∫—Ç–æ–≤–∫—É –∫–ª–∞—Å—Å–∞
    class_info = get_class_description(cls)
    
    ts_str = str(m.get('ts', '')).replace('T', ' ')[:16]
    
    # Quality Desc (—É–ª—É—á—à–µ–Ω–æ)
    q_desc = get_quality_description(prob, trade_status)
    
    # Format Location
    loc_str = flags['edge_type']
    if flags['at_edge']:
         loc_str += f" ({flags['edge_status']})"
    
    # CVD & DOI descriptions (–ò–°–ü–†–ê–í–õ–ï–ù–ù–´–ï)
    cvd_desc = get_cvd_description(m, flags)
    doi_desc = get_doi_description(m, flags)
    
    # Action map
    action_map = {
        "–ü–†–û–ü–£–°–ö": "–ù–µ —Ç—Ä–µ–π–¥–∏—Ç—å –≤–æ–æ–±—â–µ",
        "–°–õ–ê–ë–´–ô_–°–ò–ì–ù–ê–õ": "–ò–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞—Ç—å –∏–ª–∏ –æ—Å—Ç–æ—Ä–æ–∂–Ω–æ",
        "–ù–ï–ô–¢–†–ê–õ–¨–ù–´–ô": "–ñ–¥–∞—Ç—å –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è",
        "–°–ò–õ–¨–ù–´–ô_–°–ò–ì–ù–ê–õ": "–ú–æ–∂–Ω–æ —Ç—Ä–µ–π–¥–∏—Ç—å",
        "–û–ß–ï–ù–¨_–°–ò–õ–¨–ù–´–ô": "–ê–∫—Ç–∏–≤–Ω–æ —Ç—Ä–µ–π–¥–∏—Ç—å",
        "–ö–†–ò–¢–ò–ß–ï–°–ö–ò–ô": "–ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –≤–Ω–∏–º–∞–Ω–∏–µ! –ù–µ–º–µ–¥–ª–µ–Ω–Ω–æ –¥–µ–π—Å—Ç–≤–æ–≤–∞—Ç—å!"
    }
    action_text = action_map.get(trade_status, "–ù–µ—Ç —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π")
    
    # ‚úÖ –†–ê–°–®–ò–†–ï–ù–ù–´–ô –û–¢–ß–ï–¢ –° –¢–†–ê–ö–¢–û–í–ö–û–ô
    report = f"""–ö–õ–ê–°–°–ò–§–ò–ö–ê–¶–ò–Ø –°–í–ï–ß–ò
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

–î–∞—Ç–∞: {ts_str} | –¢–§: {m.get('tf')} | {m.get('symbol_clean')} | –õ–æ–∫–∞—Ü–∏—è: {loc_str}

–ö–õ–ê–°–°: {cls}
{class_info['emoji']} {class_info['–∫—Ä–∞—Ç–∫–æ–µ'].upper()}

–ù–ê–ü–†–ê–í–õ–ï–ù–ò–ï: {direction}


–í–ï–†–û–Ø–¢–ù–û–°–¢–ò –ò –û–¶–ï–ù–ö–ò:
‚Ä¢ –ù–∞–¥—ë–∂–Ω–æ—Å—Ç—å —Å–∏–≥–Ω–∞–ª–∞: {prob}% ({q_desc})
‚Ä¢ –°—Ç–∞—Ç—É—Å: {trade_status}
‚Ä¢ AQS –ë–∞–ª–ª: {aqs:.2f}


–¢–†–ê–ö–¢–û–í–ö–ê –ö–õ–ê–°–°–ê:
{class_info['–ø–æ–ª–Ω–æ–µ']}

{class_info['—Ç—Ä–∞–∫—Ç–æ–≤–∫–∞']}


–ß–¢–û –ü–†–û–ò–ó–û–®–õ–û:
{summary}


–§–ê–ö–¢–û–†–´ –ê–ù–ê–õ–ò–ó–ê:
‚Ä¢ CVD: {m.get('cvd_pct', 0):.2f}% ‚Üí {cvd_desc} {summary.split('(')[-1].strip(')') if '–ö–æ–º–ø–æ–∑–∏—Ç' in summary else ''}
‚Ä¢ ŒîOI: {m.get('doi_pct', 0):.2f}% ‚Üí {doi_desc}
‚Ä¢ –ì–µ–æ–º–µ—Ç—Ä–∏—è: CLV {m.get('clv_pct'):.0f}%, –•–≤–æ—Å—Ç L:{m.get('lower_tail_pct'):.0f}% / U:{m.get('upper_tail_pct'):.0f}%
‚Ä¢ –õ–æ–∫–∞—Ü–∏—è: {'–£ —É—Ä–æ–≤–Ω—è' if flags['at_edge'] else '–í –≤–æ–∑–¥—É—Ö–µ'}
‚Ä¢ –ü–æ—Ç–æ–∫ —Å–¥–µ–ª–æ–∫: Tilt {m.get('tilt_pct'):.1f}%


–í–´–í–û–î: {class_info['–ø–æ–ª–Ω–æ–µ'].lower()} —Å –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å—é {prob}%.


–î–ï–ô–°–¢–í–ò–ï: {action_text}
‚Üí {class_info['–¥–µ–π—Å—Ç–≤–∏–µ']}"""

    return report

# --- 3.5 VALIDATION ---
def validate_metrics(data):
    """
    Validates existence of mandatory fields (User Req 3.1).
    Uses internal App field names.
    Returns None if valid, else Error String.
    """
    # Required keys in our system (app.py)
    required_keys = [
        "ts", "symbol_clean", "tf", "range", "body_pct", "clv_pct",
        "upper_tail_pct", "lower_tail_pct", "price_sign", "cvd_pct",
        "cvd_sign", "dtrades_pct", "ratio_stable", "doi_pct",
        "liq_share_pct", "liq_squeeze", "oe", "oipos", "oi_path",
        "dpx", "price_vs_delta", "avg_trade_buy", "avg_trade_sell",
        "tilt_pct", "range_pct", "implied_price",
        # Strict Validation Keys Added:
        "tf_sens", "t_set_pct", "t_counter_pct", "t_unload_pct",
        # FIX: Added per AI Audit #3
        "liq_threshold"
    ]
    
    missing = []
    for key in required_keys:
        if key not in data or data.get(key) is None:
             # Exception: 'range' might be 0.0 (valid). 'None' is invalid.
             missing.append(key)
    
    if missing:
        return f"ERROR: –û—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç –ø–æ–ª—è: {', '.join(missing)}. –ó–∞–ø–æ–ª–Ω–∏—Ç–µ –∏–ª–∏ –ø—Ä–æ–≤–µ—Ä—å—Ç–µ –ø–∞—Ä—Å–∏–Ω–≥."
    
    return None

def run_expert_analysis(metrics_data, zone, action):
    # 1. Validation
    err = validate_metrics(metrics_data)
    if err:
        return err
        
    # 2. Generation
    return generate_diver_report(metrics_data, {'zone': zone, 'action': action})

def get_base_analysis(metrics_data, zone, action):
    """
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç (cls, prob_final) –¥–ª—è ITB, —á—Ç–æ–±—ã –Ω–µ –¥—É–±–ª–∏—Ä–æ–≤–∞—Ç—å –ª–æ–≥–∏–∫—É.
    """
    flags = prepare_logic_flags(metrics_data, {'zone': zone, 'action': action})
    aqs = calculate_aqs(metrics_data, flags)
    cls, prob, summary, direction = classify_main(metrics_data, flags, aqs)
    return cls, prob

# --- 5. INTRABAR ANALYSIS (ITB) ---

def tf_to_minutes(tf_str):
    if not tf_str: return 0
    tf_str = str(tf_str).lower()
    if tf_str.endswith('m'): return int(tf_str[:-1])
    if tf_str.endswith('h'): return int(tf_str[:-1]) * 60
    if tf_str.endswith('d'): return int(tf_str[:-1]) * 1440
    if tf_str.endswith('w'): return int(tf_str[:-1]) * 10080
    return 0

def parse_ts(ts_val):
    try:
        if isinstance(ts_val, datetime): return ts_val
        return datetime.fromisoformat(str(ts_val).replace(' ', 'T')[:16])
    except:
        return None

def run_intrabar_analysis(analyzed_candle, slices):
    """
    –í—ã–ø–æ–ª–Ω—è–µ—Ç –≤–Ω—É—Ç—Ä–∏–±–∞—Ä–æ–≤—ã–π –∞–Ω–∞–ª–∏–∑ (ITB) –Ω–∞ –æ—Å–Ω–æ–≤–µ –Ω–∞—Ä–µ–∑–∫–∏ –º–ª–∞–¥—à–µ–≥–æ –¢–§.
    KB Section 5 & 6.2
    """
    
    # === 1. –í–ê–õ–ò–î–ê–¶–ò–Ø (5.2) ===
    required_fields = ['cvd_pct', 'clv_pct', 'doi_pct', 'price_sign', 'cvd_sign', 'ts', 'tf']
    for f in required_fields:
        if f not in analyzed_candle:
            return f"‚ùå –û–®–ò–ë–ö–ê ITB: –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º–∞—è —Å–≤–µ—á–∞ –Ω–µ–ø–æ–ª–Ω–∞—è. –ù–µ—Ç –ø–æ–ª—è: {f}"
            
    if not slices:
         return "‚ùå –û–®–ò–ë–ö–ê ITB: –ü—É—Å—Ç–∞—è –Ω–∞—Ä–µ–∑–∫–∞."

    # Parse TS
    ts_main_start = parse_ts(analyzed_candle['ts'])
    main_dur = tf_to_minutes(analyzed_candle['tf'])
    ts_main_end = ts_main_start + timedelta(minutes=main_dur)
    
    # Check Coverage
    ts_slice_first = parse_ts(slices[0]['ts'])
    slice_dur = tf_to_minutes(slices[0]['tf'])
    ts_slice_last_end = parse_ts(slices[-1]['ts']) + timedelta(minutes=slice_dur) # Slice end
    
    # Allow small tolerance (e.g. 1 min)
    if ts_slice_first > ts_main_start + timedelta(minutes=2): # Tolerance
        return f"‚ùå –û–®–ò–ë–ö–ê ITB: –ù–∞—Ä–µ–∑–∫–∞ –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è –ø–æ–∑–∂–µ —Å–≤–µ—á–∏ ({ts_slice_first} > {ts_main_start})"
        
    if ts_slice_last_end < ts_main_end - timedelta(minutes=2):
        return f"‚ùå –û–®–ò–ë–ö–ê ITB: –ù–∞—Ä–µ–∑–∫–∞ –∑–∞–∫–∞–Ω—á–∏–≤–∞–µ—Ç—Å—è —Ä–∞–Ω—å—à–µ —Å–≤–µ—á–∏ ({ts_slice_last_end} < {ts_main_end})"

    # Check Continuity & Consistency
    tf_slice = slices[0]['tf']
    for i in range(len(slices)):
        s = slices[i]
        if s['tf'] != tf_slice:
            return f"‚ùå –û–®–ò–ë–ö–ê ITB: –†–∞–∑–Ω—ã–µ –¢–§ –≤ –Ω–∞—Ä–µ–∑–∫–µ ({s['tf']} != {tf_slice})"
        
        if i < len(slices) - 1:
            curr_end = parse_ts(s['ts']) + timedelta(minutes=tf_to_minutes(s['tf']))
            next_start = parse_ts(slices[i+1]['ts'])
            if curr_end != next_start:
                 # Allow gap if it's small (sometimes data has seconds diff) but strict requires logic
                 # Check delta
                 diff = abs((next_start - curr_end).total_seconds())
                 if diff > 60: # > 1 min gap
                     return f"‚ùå –û–®–ò–ë–ö–ê ITB: –†–∞–∑—Ä—ã–≤ –≤—Ä–µ–º–µ–Ω–∏ –º–µ–∂–¥—É —Å–≤–µ—á–æ–π {i+1} –∏ {i+2}"
    
    # === 2. –ú–ï–¢–†–ò–ö–ò (5.3) ===
    
    # A. SignStab
    cvd_signs = [sign(s.get('cvd_pct', 0)) for s in slices]
    dom_sign = sign(analyzed_candle.get('cvd_pct', 0))
    match_count = sum(1 for s in cvd_signs if s == dom_sign)
    sign_stab = match_count / len(slices)
    
    if sign_stab >= 0.75: q_sign = "STRONG"
    elif sign_stab > 0.50: q_sign = "WEAK"
    else: q_sign = "NOISE"
    
    # B. EdgeStab
    ps = analyzed_candle.get('price_sign')
    cs = analyzed_candle.get('cvd_sign')
    
    edge_match = 0
    if ps == 1 and cs == -1: # BULL setup
        target = 60
        edge_match = sum(1 for s in slices if s.get('clv_pct', 0) >= target)
    else: # BEAR or other
        target = 40
        edge_match = sum(1 for s in slices if s.get('clv_pct', 0) <= target)
        
    edge_stab = edge_match / len(slices)
    
    if edge_stab >= 0.75: q_edge = "STRONG"
    elif edge_stab > 0.50: q_edge = "WEAK"
    else: q_edge = "NOISE"
    
    # C. OI Stability
    oi_vals = [abs(s.get('doi_pct', 0)) for s in slices]
    avg_oi = mean(oi_vals) if oi_vals else 0
    std_oi = stdev(oi_vals) if len(oi_vals) > 1 else 0
    
    # Logic: Stable if RELATIVE variation is low OR ABSOLUTE variation is negligible
    is_stable_rel = (std_oi < (avg_oi * 0.5)) if avg_oi > 0.05 else False
    is_stable_abs = (std_oi < 0.15) # Absolute tolerance
    
    if is_stable_rel or is_stable_abs:
        q_oi = "STABLE"
    else:
        q_oi = "VOLATILE"
        
    # D. Divergence Decay
    decay_flag = False
    if len(slices) >= 4: # Need enough slices
        mid = len(slices) // 2
        p1 = slices[:mid]
        p2 = slices[mid:]
        
        s1 = [sign(x.get('cvd_pct', 0)) for x in p1]
        s2 = [sign(x.get('cvd_pct', 0)) for x in p2]
        
        def most_common(lst):
            if not lst: return 0
            c = Counter(lst).most_common(2)
            # If tie (e.g. 1 vs 1), return 0
            if len(c) > 1 and c[0][1] == c[1][1]:
                return 0
            return c[0][0]
            
        d1 = most_common(s1)
        d2 = most_common(s2)
        
        # If trend flipped or lost consistency (0)
        if d1 != d2 and d1 != 0 and d2 != 0:
            decay_flag = True
            
    # === 3. –í–ï–†–û–Ø–¢–ù–û–°–¢–¨ (5.4) ===
    # Get base prob from analyzed candle (assumes pre-injection)
    prob_base = analyzed_candle.get('prob_final', 50) 
    cls_base = analyzed_candle.get('cls', 'UNKNOWN')
    
    intrabar_flag = "UNDEFINED"
    prob_final_itb = prob_base
    oi_comment = ""
    
    if sign_stab >= 0.75 and edge_stab >= 0.75:
        intrabar_flag = "STRONG_CONFIRMATION"
        if prob_base < 60: bonus = 30; cap = 95
        elif prob_base < 80: bonus = 20; cap = 96
        else: bonus = 10; cap = 98
        prob_final_itb = min(prob_base + bonus, cap)
        oi_comment = "–û–ò —Å—Ç–∞–±–∏–ª–µ–Ω." if q_oi == "STABLE" else "–û–ò –≤–æ–ª–∞—Ç–∏–ª–µ–Ω (–Ω–µ—Å—Ç–∞–±–∏–ª–µ–Ω)."
        if q_oi == "VOLATILE": prob_final_itb -= 5
        
    elif (sign_stab > 0.50 and sign_stab < 0.75) or (edge_stab > 0.50 and edge_stab < 0.75):
        intrabar_flag = "WEAK_SUPPORT"
        prob_final_itb = min(prob_base + 10, 92)
        oi_comment = "–ò–Ω—Ç—Ä–∞–±–∞—Ä —á–∞—Å—Ç–∏—á–Ω–æ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç."
        
    elif sign_stab <= 0.50 or edge_stab <= 0.50:
        intrabar_flag = "NOISE"
        # Logic: -15 penalty for noise (matched with Bot)
        prob_final_itb = max(prob_base - 15, 20)
        if prob_final_itb < 30: cls_base = "–ù–ï–í–û–ó–ú–û–ñ–ù–û_–ö–õ–ê–°–°–ò–§–ò–¶–ò–†–û–í–ê–¢–¨ (–®—É–º ITB)"
        oi_comment = "–®—É–º: —Å–∏–≥–Ω–∞–ª –¥–µ—Ä–∂–∏—Ç—Å—è ‚â§50% –≤—Ä–µ–º–µ–Ω–∏."
        
    else:
        prob_final_itb = max(prob_base - 20, 10)
        oi_comment = "–ù–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–æ—Å—Ç—å."
        
    # Decay
    if decay_flag:
        prob_final_itb -= 20
        
    prob_final_itb = max(min(prob_final_itb, 99), 15)
    
    # === 4. –û–¢–ß–ï–¢ (6.2) ===
    
    report = f"""
–í–ù–£–¢–†–ò–ë–ê–†–û–í–´–ô –ê–ù–ê–õ–ò–ó (ITB)
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 
–ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º–∞—è —Å–≤–µ—á–∞: {analyzed_candle.get('ts')} | {analyzed_candle.get('tf')} | {analyzed_candle.get('symbol_clean')}
–ù–∞—Ä–µ–∑–∫–∞: {tf_slice} ({len(slices)} —Å–≤–µ—á–µ–π)
 
–ë–∞–∑–æ–≤—ã–π –∫–ª–∞—Å—Å: {analyzed_candle.get('cls')}
–ë–∞–∑–æ–≤–∞—è –Ω–∞–¥—ë–∂–Ω–æ—Å—Ç—å: {prob_base}%
 
1. –î–ò–ù–ê–ú–ò–ö–ê –í–ù–£–¢–†–ò –°–í–ï–ß–ò
---------------------------------------------------------------
–ê–≥—Ä–µ—Å—Å–∏—è (CVD): {q_sign} (–£—Å—Ç–æ–π—á–∏–≤–æ—Å—Ç—å: {sign_stab*100:.0f}%)
–ì–µ–æ–º–µ—Ç—Ä–∏—è:      {q_edge} (–£–¥–µ—Ä–∂–∞–Ω–∏–µ —Ñ–æ—Ä–º—ã: {edge_stab*100:.0f}%)
–û—Ç–∫—Ä—ã—Ç—ã–π –∏–Ω—Ç–µ—Ä–µ—Å: {q_oi} (–í–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç—å: {std_oi:.2f})
–†–∞—Å–ø–∞–¥ –¥–∏–≤–µ—Ä–≥–µ–Ω—Ü–∏–∏: {"‚ö†Ô∏è –û–ë–ù–ê–†–£–ñ–ï–ù (-20%)" if decay_flag else "–ù–ï–¢"}

2. –í–õ–ò–Ø–ù–ò–ï –ù–ê –°–ò–ì–ù–ê–õ
---------------------------------------------------------------
–ë–∞–∑–æ–≤–∞—è –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å:   {prob_base}%
–ü–æ–ø—Ä–∞–≤–∫–∞ ITB:          {prob_final_itb - prob_base:+d}% ({intrabar_flag})
–ò–¢–û–ì–û–í–ê–Ø –í–ï–†–û–Ø–¢–ù–û–°–¢–¨:  {prob_final_itb}%
 
–ö–ª–∞—Å—Å –ø–æ—Å–ª–µ ITB: {cls_base}
 
3. –ü–û–Ø–°–ù–ï–ù–ò–ï
---------------------------------------------------------------
{oi_comment}
{"–í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å —Å–Ω–∏–∂–µ–Ω–∞ –∑–∞ —Ä–∞—Å–ø–∞–¥ –¥–∏–≤–µ—Ä–≥–µ–Ω—Ü–∏–∏ (—Å–º–µ–Ω–∞ –∑–Ω–∞–∫–∞)." if decay_flag else ""}
"""
    return report
